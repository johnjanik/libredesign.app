/**
 * Gradient Shaders
 *
 * GLSL shaders for linear and radial gradient rendering.
 * Supports up to 8 color stops with configurable positions.
 */
/**
 * Gradient vertex shader - passes object-space position to fragment shader
 */
export declare const GRADIENT_VERTEX_SHADER = "#version 300 es\nprecision highp float;\n\nuniform mat3 uViewProjection;\nuniform mat3 uTransform;\n\nin vec2 aPosition;\n\nout vec2 vPosition;\n\nvoid main() {\n  // Pass object-space position to fragment shader for gradient calculation\n  vPosition = aPosition;\n\n  // Transform to clip space for rendering\n  vec3 pos = uViewProjection * uTransform * vec3(aPosition, 1.0);\n  gl_Position = vec4(pos.xy, 0.0, 1.0);\n}\n";
/**
 * Linear gradient fragment shader
 */
export declare const LINEAR_GRADIENT_FRAGMENT_SHADER = "#version 300 es\nprecision highp float;\n\n// Maximum number of color stops\n#define MAX_STOPS 8\n\n// Gradient parameters\nuniform vec2 uGradientStart;      // Start point in object space\nuniform vec2 uGradientEnd;        // End point in object space\nuniform mat3 uGradientTransform;  // Transform applied to gradient\n\n// Color stops\nuniform int uStopCount;\nuniform vec4 uStopColors[MAX_STOPS];\nuniform float uStopPositions[MAX_STOPS];\n\n// Overall opacity\nuniform float uOpacity;\n\nin vec2 vPosition;\nout vec4 fragColor;\n\nvec4 sampleGradient(float t) {\n  // Clamp t to [0, 1]\n  t = clamp(t, 0.0, 1.0);\n\n  // Handle edge cases\n  if (uStopCount <= 0) {\n    return vec4(0.0);\n  }\n  if (uStopCount == 1) {\n    return uStopColors[0];\n  }\n\n  // Find the two stops to interpolate between\n  int i = 0;\n  for (; i < uStopCount - 1; i++) {\n    if (t <= uStopPositions[i + 1]) {\n      break;\n    }\n  }\n\n  // Ensure we don't go out of bounds\n  if (i >= uStopCount - 1) {\n    return uStopColors[uStopCount - 1];\n  }\n\n  // Interpolate between stops\n  float t0 = uStopPositions[i];\n  float t1 = uStopPositions[i + 1];\n  float localT = (t1 > t0) ? (t - t0) / (t1 - t0) : 0.0;\n  localT = clamp(localT, 0.0, 1.0);\n\n  return mix(uStopColors[i], uStopColors[i + 1], localT);\n}\n\nvoid main() {\n  // Apply gradient transform to position\n  vec2 pos = (uGradientTransform * vec3(vPosition, 1.0)).xy;\n\n  // Calculate gradient vector\n  vec2 gradientVec = uGradientEnd - uGradientStart;\n  float gradientLenSq = dot(gradientVec, gradientVec);\n\n  // Calculate position along gradient (0 to 1)\n  float t = 0.0;\n  if (gradientLenSq > 0.0001) {\n    t = dot(pos - uGradientStart, gradientVec) / gradientLenSq;\n  }\n\n  // Sample gradient and apply opacity\n  vec4 color = sampleGradient(t);\n  fragColor = color * uOpacity;\n}\n";
/**
 * Radial gradient fragment shader
 */
export declare const RADIAL_GRADIENT_FRAGMENT_SHADER = "#version 300 es\nprecision highp float;\n\n// Maximum number of color stops\n#define MAX_STOPS 8\n\n// Gradient parameters\nuniform vec2 uGradientCenter;     // Center point in object space\nuniform vec2 uGradientRadius;     // Radii (x, y) for ellipse support\nuniform vec2 uGradientFocus;      // Focus point offset (for focal gradients)\nuniform mat3 uGradientTransform;  // Transform applied to gradient\n\n// Color stops\nuniform int uStopCount;\nuniform vec4 uStopColors[MAX_STOPS];\nuniform float uStopPositions[MAX_STOPS];\n\n// Overall opacity\nuniform float uOpacity;\n\nin vec2 vPosition;\nout vec4 fragColor;\n\nvec4 sampleGradient(float t) {\n  // Clamp t to [0, 1]\n  t = clamp(t, 0.0, 1.0);\n\n  // Handle edge cases\n  if (uStopCount <= 0) {\n    return vec4(0.0);\n  }\n  if (uStopCount == 1) {\n    return uStopColors[0];\n  }\n\n  // Find the two stops to interpolate between\n  int i = 0;\n  for (; i < uStopCount - 1; i++) {\n    if (t <= uStopPositions[i + 1]) {\n      break;\n    }\n  }\n\n  // Ensure we don't go out of bounds\n  if (i >= uStopCount - 1) {\n    return uStopColors[uStopCount - 1];\n  }\n\n  // Interpolate between stops\n  float t0 = uStopPositions[i];\n  float t1 = uStopPositions[i + 1];\n  float localT = (t1 > t0) ? (t - t0) / (t1 - t0) : 0.0;\n  localT = clamp(localT, 0.0, 1.0);\n\n  return mix(uStopColors[i], uStopColors[i + 1], localT);\n}\n\nvoid main() {\n  // Apply gradient transform to position\n  vec2 pos = (uGradientTransform * vec3(vPosition, 1.0)).xy;\n\n  // Calculate distance from center, normalized by radius\n  vec2 offset = pos - uGradientCenter;\n\n  // Handle elliptical radii\n  float rx = max(uGradientRadius.x, 0.0001);\n  float ry = max(uGradientRadius.y, 0.0001);\n  vec2 normalized = vec2(offset.x / rx, offset.y / ry);\n\n  // Distance in normalized space\n  float t = length(normalized);\n\n  // Sample gradient and apply opacity\n  vec4 color = sampleGradient(t);\n  fragColor = color * uOpacity;\n}\n";
/**
 * Angular/conic gradient fragment shader
 */
export declare const ANGULAR_GRADIENT_FRAGMENT_SHADER = "#version 300 es\nprecision highp float;\n\n// Maximum number of color stops\n#define MAX_STOPS 8\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n// Gradient parameters\nuniform vec2 uGradientCenter;     // Center point in object space\nuniform float uStartAngle;        // Starting angle in radians\nuniform mat3 uGradientTransform;  // Transform applied to gradient\n\n// Color stops\nuniform int uStopCount;\nuniform vec4 uStopColors[MAX_STOPS];\nuniform float uStopPositions[MAX_STOPS];\n\n// Overall opacity\nuniform float uOpacity;\n\nin vec2 vPosition;\nout vec4 fragColor;\n\nvec4 sampleGradient(float t) {\n  // Wrap t to [0, 1]\n  t = fract(t);\n\n  // Handle edge cases\n  if (uStopCount <= 0) {\n    return vec4(0.0);\n  }\n  if (uStopCount == 1) {\n    return uStopColors[0];\n  }\n\n  // Find the two stops to interpolate between\n  int i = 0;\n  for (; i < uStopCount - 1; i++) {\n    if (t <= uStopPositions[i + 1]) {\n      break;\n    }\n  }\n\n  // Ensure we don't go out of bounds\n  if (i >= uStopCount - 1) {\n    i = uStopCount - 2;\n  }\n\n  // Interpolate between stops\n  float t0 = uStopPositions[i];\n  float t1 = uStopPositions[i + 1];\n  float localT = (t1 > t0) ? (t - t0) / (t1 - t0) : 0.0;\n  localT = clamp(localT, 0.0, 1.0);\n\n  return mix(uStopColors[i], uStopColors[i + 1], localT);\n}\n\nvoid main() {\n  // Apply gradient transform to position\n  vec2 pos = (uGradientTransform * vec3(vPosition, 1.0)).xy;\n\n  // Calculate angle from center\n  vec2 offset = pos - uGradientCenter;\n  float angle = atan(offset.y, offset.x);\n\n  // Normalize angle to [0, 1] starting from startAngle\n  float t = (angle - uStartAngle + PI) / TWO_PI;\n  t = fract(t); // Wrap around\n\n  // Sample gradient and apply opacity\n  vec4 color = sampleGradient(t);\n  fragColor = color * uOpacity;\n}\n";
/**
 * Diamond gradient fragment shader (square-based radial gradient)
 */
export declare const DIAMOND_GRADIENT_FRAGMENT_SHADER = "#version 300 es\nprecision highp float;\n\n// Maximum number of color stops\n#define MAX_STOPS 8\n\n// Gradient parameters\nuniform vec2 uGradientCenter;     // Center point in object space\nuniform vec2 uGradientRadius;     // Radii (x, y)\nuniform mat3 uGradientTransform;  // Transform applied to gradient\n\n// Color stops\nuniform int uStopCount;\nuniform vec4 uStopColors[MAX_STOPS];\nuniform float uStopPositions[MAX_STOPS];\n\n// Overall opacity\nuniform float uOpacity;\n\nin vec2 vPosition;\nout vec4 fragColor;\n\nvec4 sampleGradient(float t) {\n  // Clamp t to [0, 1]\n  t = clamp(t, 0.0, 1.0);\n\n  // Handle edge cases\n  if (uStopCount <= 0) {\n    return vec4(0.0);\n  }\n  if (uStopCount == 1) {\n    return uStopColors[0];\n  }\n\n  // Find the two stops to interpolate between\n  int i = 0;\n  for (; i < uStopCount - 1; i++) {\n    if (t <= uStopPositions[i + 1]) {\n      break;\n    }\n  }\n\n  // Ensure we don't go out of bounds\n  if (i >= uStopCount - 1) {\n    return uStopColors[uStopCount - 1];\n  }\n\n  // Interpolate between stops\n  float t0 = uStopPositions[i];\n  float t1 = uStopPositions[i + 1];\n  float localT = (t1 > t0) ? (t - t0) / (t1 - t0) : 0.0;\n  localT = clamp(localT, 0.0, 1.0);\n\n  return mix(uStopColors[i], uStopColors[i + 1], localT);\n}\n\nvoid main() {\n  // Apply gradient transform to position\n  vec2 pos = (uGradientTransform * vec3(vPosition, 1.0)).xy;\n\n  // Calculate distance from center using Manhattan distance (diamond shape)\n  vec2 offset = abs(pos - uGradientCenter);\n\n  // Normalize by radius\n  float rx = max(uGradientRadius.x, 0.0001);\n  float ry = max(uGradientRadius.y, 0.0001);\n\n  // Manhattan distance normalized\n  float t = offset.x / rx + offset.y / ry;\n\n  // Sample gradient and apply opacity\n  vec4 color = sampleGradient(t);\n  fragColor = color * uOpacity;\n}\n";
//# sourceMappingURL=gradient.glsl.d.ts.map