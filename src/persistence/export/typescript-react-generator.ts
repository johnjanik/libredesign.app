/**
 * TypeScript React Code Generator
 *
 * Generate React functional components from scene graph nodes.
 */

import type { NodeId } from '@core/types/common';
import type { RGBA } from '@core/types/color';
import type { VectorPath } from '@core/types/geometry';
import type { SceneGraph } from '@scene/graph/scene-graph';
import type { NodeData, FrameNodeData, VectorNodeData, TextNodeData } from '@scene/nodes/base-node';

/**
 * TypeScript React code generation options
 */
export interface TypeScriptReactGeneratorOptions {
  /** Component name (default: derived from node name) */
  componentName?: string | undefined;
  /** Use CSS modules or inline styles (default: 'inline') */
  styleMode?: 'inline' | 'css-modules' | undefined;
  /** Include TypeScript types (default: true) */
  includeTypes?: boolean | undefined;
  /** Include comments (default: true) */
  includeComments?: boolean | undefined;
  /** Export type (default: 'named') */
  exportType?: 'named' | 'default' | undefined;
}

/**
 * TypeScript React code generation result
 */
export interface TypeScriptReactGeneratorResult {
  /** Generated code */
  readonly code: string;
  /** CSS module styles (if styleMode is 'css-modules') */
  readonly cssModule: string;
  /** File extension */
  readonly extension: string;
  /** Blob for download */
  readonly blob: Blob;
  /** Download URL */
  readonly url: string;
}

/**
 * TypeScript React Code Generator
 */
export class TypeScriptReactGenerator {
  private sceneGraph: SceneGraph;
  private colorIndex = 0;
  private extractedColors: Map<string, { name: string; rgba: RGBA }> = new Map();
  private usedStyleNames: Set<string> = new Set();

  constructor(sceneGraph: SceneGraph) {
    this.sceneGraph = sceneGraph;
  }

  /**
   * Generate React code for a node.
   */
  generate(nodeId: NodeId, options: TypeScriptReactGeneratorOptions = {}): TypeScriptReactGeneratorResult {
    const node = this.sceneGraph.getNode(nodeId);
    if (!node) {
      throw new Error(`Node not found: ${nodeId}`);
    }

    const componentName = options.componentName ?? this.sanitizeName(node.name || node.type);
    const styleMode = options.styleMode ?? 'inline';
    const includeTypes = options.includeTypes ?? true;
    const includeComments = options.includeComments ?? true;
    const exportType = options.exportType ?? 'named';

    // Reset extraction state
    this.colorIndex = 0;
    this.extractedColors.clear();
    this.usedStyleNames.clear();

    // Extract colors first
    this.extractColors(nodeId);

    let code: string;
    let cssModule = '';

    if (styleMode === 'css-modules') {
      const result = this.generateWithCSSModules(nodeId, componentName, includeTypes, includeComments, exportType);
      code = result.code;
      cssModule = result.cssModule;
    } else {
      code = this.generateWithInlineStyles(nodeId, componentName, includeTypes, includeComments, exportType);
    }

    const blob = new Blob([code], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);

    return {
      code,
      cssModule,
      extension: 'tsx',
      blob,
      url,
    };
  }

  /**
   * Download the generated code.
   */
  download(
    nodeId: NodeId,
    filename?: string,
    options: TypeScriptReactGeneratorOptions = {}
  ): void {
    const result = this.generate(nodeId, options);
    const finalFilename = filename ?? `Component.tsx`;

    const link = document.createElement('a');
    link.href = result.url;
    link.download = finalFilename;
    link.click();

    URL.revokeObjectURL(result.url);
  }

  // =========================================================================
  // Inline Styles Generation
  // =========================================================================

  private generateWithInlineStyles(
    nodeId: NodeId,
    componentName: string,
    includeTypes: boolean,
    includeComments: boolean,
    exportType: 'named' | 'default'
  ): string {
    const parts: string[] = [];

    // Header comment
    if (includeComments) {
      parts.push('// Generated by DesignLibre');
      parts.push('// Do not modify directly');
      parts.push('');
    }

    // Imports
    parts.push("import React from 'react';");
    parts.push('');

    // Props interface
    if (includeTypes) {
      parts.push(`interface ${componentName}Props {`);
      parts.push('  className?: string;');
      parts.push('  style?: React.CSSProperties;');
      parts.push('}');
      parts.push('');
    }

    // Component
    const propsType = includeTypes ? `: ${componentName}Props` : '';
    const exportKeyword = exportType === 'default' ? 'export default' : 'export';

    parts.push(`${exportKeyword} function ${componentName}({ className, style }${propsType}) {`);
    parts.push('  return (');
    parts.push(this.generateJSXBody(nodeId, 4));
    parts.push('  );');
    parts.push('}');

    // Named export helper if default
    if (exportType === 'default') {
      parts.push('');
    }

    return parts.join('\n');
  }

  private generateJSXBody(nodeId: NodeId, indent: number): string {
    const node = this.sceneGraph.getNode(nodeId);
    if (!node) return '';

    const spaces = ' '.repeat(indent);

    switch (node.type) {
      case 'FRAME':
      case 'COMPONENT':
        return this.generateFrameJSX(node as FrameNodeData, nodeId, indent);
      case 'VECTOR':
        return this.generateVectorJSX(node as VectorNodeData, indent);
      case 'TEXT':
        return this.generateTextJSX(node as TextNodeData, indent);
      case 'GROUP':
        return this.generateGroupJSX(nodeId, indent);
      case 'IMAGE':
        return this.generateImageJSX(node, indent);
      default:
        return `${spaces}<div />`;
    }
  }

  private generateFrameJSX(
    node: FrameNodeData,
    nodeId: NodeId,
    indent: number
  ): string {
    const spaces = ' '.repeat(indent);
    const parts: string[] = [];

    const childIds = this.sceneGraph.getChildIds(nodeId);
    const hasChildren = childIds.length > 0;
    const style = this.generateInlineStyle(node);

    // Determine if we should merge className prop (only for root)
    const isRoot = indent === 4;
    const classAttr = isRoot ? 'className={className}' : '';
    const styleAttr = isRoot
      ? `style={{ ...${style}, ...style }}`
      : `style={${style}}`;

    if (hasChildren) {
      parts.push(`${spaces}<div ${classAttr} ${styleAttr}>`.trim().replace(/\s+/g, ' '));

      for (const childId of childIds) {
        parts.push(this.generateJSXBody(childId, indent + 2));
      }

      parts.push(`${spaces}</div>`);
    } else {
      parts.push(`${spaces}<div ${classAttr} ${styleAttr} />`.trim().replace(/\s+/g, ' '));
    }

    return parts.join('\n');
  }

  private generateVectorJSX(node: VectorNodeData, indent: number): string {
    const spaces = ' '.repeat(indent);
    const parts: string[] = [];

    const path = node.vectorPaths?.[0];
    if (!path) {
      return `${spaces}<div />`;
    }

    const pathData = this.generateSVGPath(path);
    const fill = this.getFirstSolidFill(node.fills);
    const stroke = this.getFirstSolidStroke(node.strokes);
    const fillColor = fill ? this.rgbaToCSS(fill) : 'none';
    const strokeColor = stroke ? this.rgbaToCSS(stroke) : 'none';

    parts.push(`${spaces}<svg`);
    parts.push(`${spaces}  width={${node.width}}`);
    parts.push(`${spaces}  height={${node.height}}`);
    parts.push(`${spaces}  viewBox="0 0 ${node.width} ${node.height}"`);
    parts.push(`${spaces}>`);
    parts.push(`${spaces}  <path`);
    parts.push(`${spaces}    d="${pathData}"`);
    parts.push(`${spaces}    fill="${fillColor}"`);
    if (stroke) {
      parts.push(`${spaces}    stroke="${strokeColor}"`);
      parts.push(`${spaces}    strokeWidth={${node.strokeWeight ?? 1}}`);
    }
    parts.push(`${spaces}  />`);
    parts.push(`${spaces}</svg>`);

    return parts.join('\n');
  }

  private generateTextJSX(node: TextNodeData, indent: number): string {
    const spaces = ' '.repeat(indent);
    const parts: string[] = [];

    const firstStyle = node.textStyles[0];
    const style: Record<string, string | number> = {};

    if (firstStyle) {
      style['fontSize'] = firstStyle.fontSize;
      style['fontFamily'] = `'${firstStyle.fontFamily}', sans-serif`;
      style['fontWeight'] = firstStyle.fontWeight;

      if (firstStyle.letterSpacing) {
        style['letterSpacing'] = firstStyle.letterSpacing;
      }
      if (firstStyle.lineHeight !== 'AUTO') {
        style['lineHeight'] = `${firstStyle.lineHeight}px`;
      }
      if (firstStyle.textDecoration !== 'NONE') {
        style['textDecoration'] = firstStyle.textDecoration.toLowerCase();
      }
    }

    // Text color
    const fill = this.getFirstSolidFill(node.fills);
    if (fill) {
      style['color'] = this.rgbaToCSS(fill);
    }

    // Text alignment
    style['textAlign'] = node.textAlignHorizontal.toLowerCase();

    // Size and position
    style['width'] = node.width;
    style['height'] = node.height;

    const styleStr = this.objectToJSX(style);
    const escapedText = this.escapeJSXText(node.characters);

    parts.push(`${spaces}<span style={${styleStr}}>`);
    parts.push(`${spaces}  ${escapedText}`);
    parts.push(`${spaces}</span>`);

    return parts.join('\n');
  }

  private generateGroupJSX(nodeId: NodeId, indent: number): string {
    const spaces = ' '.repeat(indent);
    const parts: string[] = [];
    const childIds = this.sceneGraph.getChildIds(nodeId);

    parts.push(`${spaces}<div style={{ position: 'relative' }}>`);
    for (const childId of childIds) {
      parts.push(this.generateJSXBody(childId, indent + 2));
    }
    parts.push(`${spaces}</div>`);

    return parts.join('\n');
  }

  private generateImageJSX(node: NodeData, indent: number): string {
    const spaces = ' '.repeat(indent);
    const n = node as { width: number; height: number; imageRef?: string };

    return `${spaces}<img src="${n.imageRef ?? ''}" alt="" style={{ width: ${n.width}, height: ${n.height}, objectFit: 'cover' }} />`;
  }

  private generateInlineStyle(node: NodeData): string {
    const style: Record<string, string | number> = {};

    // Layout mode
    if ('autoLayout' in node) {
      const frame = node as FrameNodeData;
      if (frame.autoLayout?.mode === 'HORIZONTAL') {
        style['display'] = 'flex';
        style['flexDirection'] = 'row';
        if (frame.autoLayout.itemSpacing) {
          style['gap'] = frame.autoLayout.itemSpacing;
        }
      } else if (frame.autoLayout?.mode === 'VERTICAL') {
        style['display'] = 'flex';
        style['flexDirection'] = 'column';
        if (frame.autoLayout.itemSpacing) {
          style['gap'] = frame.autoLayout.itemSpacing;
        }
      } else {
        style['position'] = 'relative';
      }

      // Padding
      if (frame.autoLayout?.paddingTop) style['paddingTop'] = frame.autoLayout.paddingTop;
      if (frame.autoLayout?.paddingRight) style['paddingRight'] = frame.autoLayout.paddingRight;
      if (frame.autoLayout?.paddingBottom) style['paddingBottom'] = frame.autoLayout.paddingBottom;
      if (frame.autoLayout?.paddingLeft) style['paddingLeft'] = frame.autoLayout.paddingLeft;

      // Alignment
      if (frame.autoLayout?.primaryAxisAlignItems) {
        const alignMap: Record<string, string> = {
          'MIN': 'flex-start',
          'CENTER': 'center',
          'MAX': 'flex-end',
          'SPACE_BETWEEN': 'space-between',
        };
        style['justifyContent'] = alignMap[frame.autoLayout.primaryAxisAlignItems] ?? 'flex-start';
      }
      if (frame.autoLayout?.counterAxisAlignItems) {
        const alignMap: Record<string, string> = {
          'MIN': 'flex-start',
          'CENTER': 'center',
          'MAX': 'flex-end',
        };
        style['alignItems'] = alignMap[frame.autoLayout.counterAxisAlignItems] ?? 'flex-start';
      }
    }

    // Size
    if ('width' in node && 'height' in node) {
      const n = node as { width: number; height: number };
      style['width'] = n.width;
      style['height'] = n.height;
    }

    // Background
    if ('fills' in node) {
      const fill = this.getFirstSolidFill((node as FrameNodeData).fills);
      if (fill) {
        style['backgroundColor'] = this.rgbaToCSS(fill);
      }
    }

    // Border radius
    if ('cornerRadius' in node) {
      const radius = (node as { cornerRadius: number }).cornerRadius;
      if (radius > 0) {
        style['borderRadius'] = radius;
      }
    }

    // Opacity
    if ('opacity' in node) {
      const opacity = (node as { opacity: number }).opacity;
      if (opacity !== 1) {
        style['opacity'] = opacity;
      }
    }

    // Rotation
    if ('rotation' in node) {
      const rotation = (node as { rotation: number }).rotation;
      if (rotation && rotation !== 0) {
        style['transform'] = `rotate(${rotation}deg)`;
      }
    }

    // Stroke/border
    if ('strokes' in node && 'strokeWeight' in node) {
      const stroke = this.getFirstSolidStroke((node as VectorNodeData).strokes);
      const weight = (node as { strokeWeight: number }).strokeWeight;
      if (stroke && weight > 0) {
        style['border'] = `${weight}px solid ${this.rgbaToCSS(stroke)}`;
      }
    }

    // Shadow
    if ('effects' in node) {
      const effects = (node as { effects: readonly unknown[] }).effects ?? [];
      const shadows: string[] = [];
      for (const effect of effects) {
        const e = effect as { type: string; visible?: boolean; color?: RGBA; offset?: { x: number; y: number }; radius?: number };
        if (e.type === 'DROP_SHADOW' && e.visible !== false && e.color) {
          shadows.push(`${e.offset?.x ?? 0}px ${e.offset?.y ?? 0}px ${e.radius ?? 0}px ${this.rgbaToCSS(e.color)}`);
        }
      }
      if (shadows.length > 0) {
        style['boxShadow'] = shadows.join(', ');
      }
    }

    return this.objectToJSX(style);
  }

  // =========================================================================
  // CSS Modules Generation
  // =========================================================================

  private generateWithCSSModules(
    nodeId: NodeId,
    componentName: string,
    includeTypes: boolean,
    includeComments: boolean,
    exportType: 'named' | 'default'
  ): { code: string; cssModule: string } {
    const cssClasses: Map<string, Record<string, string | number>> = new Map();

    // Generate JSX with class references
    const jsx = this.generateJSXBodyWithClasses(nodeId, 4, cssClasses, 'root');

    const parts: string[] = [];

    // Header comment
    if (includeComments) {
      parts.push('// Generated by DesignLibre');
      parts.push('// Do not modify directly');
      parts.push('');
    }

    // Imports
    parts.push("import React from 'react';");
    parts.push(`import styles from './${componentName}.module.css';`);
    parts.push('');

    // Props interface
    if (includeTypes) {
      parts.push(`interface ${componentName}Props {`);
      parts.push('  className?: string;');
      parts.push('}');
      parts.push('');
    }

    // Component
    const propsType = includeTypes ? `: ${componentName}Props` : '';
    const exportKeyword = exportType === 'default' ? 'export default' : 'export';

    parts.push(`${exportKeyword} function ${componentName}({ className }${propsType}) {`);
    parts.push('  return (');
    parts.push(jsx);
    parts.push('  );');
    parts.push('}');

    // Generate CSS module
    const cssLines: string[] = [];
    for (const [className, styleObj] of cssClasses) {
      cssLines.push(`.${className} {`);
      for (const [prop, value] of Object.entries(styleObj)) {
        const cssProp = prop.replace(/([A-Z])/g, '-$1').toLowerCase();
        const cssValue = typeof value === 'number' ? `${value}px` : value;
        cssLines.push(`  ${cssProp}: ${cssValue};`);
      }
      cssLines.push('}');
      cssLines.push('');
    }

    return {
      code: parts.join('\n'),
      cssModule: cssLines.join('\n'),
    };
  }

  private generateJSXBodyWithClasses(
    nodeId: NodeId,
    indent: number,
    cssClasses: Map<string, Record<string, string | number>>,
    baseName: string
  ): string {
    const node = this.sceneGraph.getNode(nodeId);
    if (!node) return '';

    const spaces = ' '.repeat(indent);
    const className = this.getUniqueStyleName(baseName);
    const style = this.generateStyleObject(node);
    cssClasses.set(className, style);

    const childIds = this.sceneGraph.getChildIds(nodeId);
    const hasChildren = childIds.length > 0;

    const isRoot = indent === 4;
    const classExpr = isRoot
      ? `{\`\${styles.${className}} \${className ?? ''}\`}`
      : `{styles.${className}}`;

    if (hasChildren) {
      const parts: string[] = [];
      parts.push(`${spaces}<div className=${classExpr}>`);

      let childIndex = 0;
      for (const childId of childIds) {
        const childNode = this.sceneGraph.getNode(childId);
        const childName = childNode ? this.sanitizeName(childNode.name || `child${childIndex}`) : `child${childIndex}`;
        parts.push(this.generateJSXBodyWithClasses(childId, indent + 2, cssClasses, childName));
        childIndex++;
      }

      parts.push(`${spaces}</div>`);
      return parts.join('\n');
    } else {
      return `${spaces}<div className=${classExpr} />`;
    }
  }

  private generateStyleObject(node: NodeData): Record<string, string | number> {
    const style: Record<string, string | number> = {};

    // Similar to generateInlineStyle but returns object format for CSS
    if ('autoLayout' in node) {
      const frame = node as FrameNodeData;
      if (frame.autoLayout?.mode === 'HORIZONTAL') {
        style['display'] = 'flex';
        style['flexDirection'] = 'row';
        if (frame.autoLayout.itemSpacing) {
          style['gap'] = frame.autoLayout.itemSpacing;
        }
      } else if (frame.autoLayout?.mode === 'VERTICAL') {
        style['display'] = 'flex';
        style['flexDirection'] = 'column';
        if (frame.autoLayout.itemSpacing) {
          style['gap'] = frame.autoLayout.itemSpacing;
        }
      }
    }

    if ('width' in node && 'height' in node) {
      const n = node as { width: number; height: number };
      style['width'] = n.width;
      style['height'] = n.height;
    }

    if ('fills' in node) {
      const fill = this.getFirstSolidFill((node as FrameNodeData).fills);
      if (fill) {
        style['backgroundColor'] = this.rgbaToCSS(fill);
      }
    }

    if ('cornerRadius' in node) {
      const radius = (node as { cornerRadius: number }).cornerRadius;
      if (radius > 0) {
        style['borderRadius'] = radius;
      }
    }

    if ('opacity' in node) {
      const opacity = (node as { opacity: number }).opacity;
      if (opacity !== 1) {
        style['opacity'] = opacity;
      }
    }

    return style;
  }

  // =========================================================================
  // SVG Path Generation
  // =========================================================================

  private generateSVGPath(path: VectorPath): string {
    const parts: string[] = [];

    for (const cmd of path.commands) {
      switch (cmd.type) {
        case 'M':
          parts.push(`M ${cmd.x} ${cmd.y}`);
          break;
        case 'L':
          parts.push(`L ${cmd.x} ${cmd.y}`);
          break;
        case 'C':
          parts.push(`C ${cmd.x1} ${cmd.y1} ${cmd.x2} ${cmd.y2} ${cmd.x} ${cmd.y}`);
          break;
        case 'Z':
          parts.push('Z');
          break;
      }
    }

    return parts.join(' ');
  }

  // =========================================================================
  // Helper Methods
  // =========================================================================

  private extractColors(nodeId: NodeId): void {
    const node = this.sceneGraph.getNode(nodeId);
    if (!node) return;

    if ('fills' in node) {
      const fills = (node as FrameNodeData).fills ?? [];
      for (const fill of fills) {
        if (fill.type === 'SOLID' && fill.visible !== false && fill.color) {
          this.registerColor(fill.color);
        }
      }
    }

    if ('strokes' in node) {
      const strokes = (node as VectorNodeData).strokes ?? [];
      for (const stroke of strokes) {
        if (stroke.type === 'SOLID' && stroke.visible !== false && stroke.color) {
          this.registerColor(stroke.color);
        }
      }
    }

    const childIds = this.sceneGraph.getChildIds(nodeId);
    for (const childId of childIds) {
      this.extractColors(childId);
    }
  }

  private registerColor(color: RGBA): string {
    const key = this.colorToKey(color);
    if (!this.extractedColors.has(key)) {
      const name = `color${++this.colorIndex}`;
      this.extractedColors.set(key, { name, rgba: color });
    }
    return this.extractedColors.get(key)!.name;
  }

  private colorToKey(color: RGBA): string {
    return `${color.r.toFixed(3)}-${color.g.toFixed(3)}-${color.b.toFixed(3)}-${color.a.toFixed(3)}`;
  }

  private rgbaToCSS(color: RGBA): string {
    const r = Math.round(color.r * 255);
    const g = Math.round(color.g * 255);
    const b = Math.round(color.b * 255);

    if (color.a === 1) {
      return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }
    return `rgba(${r}, ${g}, ${b}, ${color.a.toFixed(2)})`;
  }

  private getFirstSolidFill(fills: readonly { type: string; visible?: boolean; color?: RGBA }[] | undefined): RGBA | null {
    if (!fills) return null;
    const solid = fills.find(f => f.type === 'SOLID' && f.visible !== false);
    return solid?.color ?? null;
  }

  private getFirstSolidStroke(strokes: readonly { type: string; visible?: boolean; color?: RGBA }[] | undefined): RGBA | null {
    if (!strokes) return null;
    const solid = strokes.find(s => s.type === 'SOLID' && s.visible !== false);
    return solid?.color ?? null;
  }

  private sanitizeName(name: string): string {
    // Convert to PascalCase for React components
    return name
      .replace(/[^a-zA-Z0-9\s]/g, '')
      .split(/\s+/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('')
      .replace(/^(\d)/, '_$1') || 'Component';
  }

  private getUniqueStyleName(base: string): string {
    let name = base.replace(/[^a-zA-Z0-9]/g, '');
    if (!name) name = 'element';

    // Make first letter lowercase for CSS class
    name = name.charAt(0).toLowerCase() + name.slice(1);

    if (!this.usedStyleNames.has(name)) {
      this.usedStyleNames.add(name);
      return name;
    }

    let counter = 2;
    while (this.usedStyleNames.has(`${name}${counter}`)) {
      counter++;
    }
    const uniqueName = `${name}${counter}`;
    this.usedStyleNames.add(uniqueName);
    return uniqueName;
  }

  private objectToJSX(obj: Record<string, string | number>): string {
    const entries = Object.entries(obj);
    if (entries.length === 0) return '{}';

    const parts = entries.map(([key, value]) => {
      if (typeof value === 'string') {
        return `${key}: '${value}'`;
      }
      return `${key}: ${value}`;
    });

    return `{ ${parts.join(', ')} }`;
  }

  private escapeJSXText(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;')
      .replace(/{/g, '&#123;')
      .replace(/}/g, '&#125;');
  }
}

/**
 * Create a TypeScript React code generator.
 */
export function createTypeScriptReactGenerator(sceneGraph: SceneGraph): TypeScriptReactGenerator {
  return new TypeScriptReactGenerator(sceneGraph);
}
