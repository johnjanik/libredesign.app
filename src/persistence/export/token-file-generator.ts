/**
 * Platform Token File Generator
 *
 * Generates platform-specific token files for native development:
 * - SwiftUI: DesignTokens.swift
 * - Compose: Theme.kt
 *
 * These files can be imported into native projects for design-code consistency.
 */

import type { ExtractedTokens, ColorToken, SpacingToken, TypographyToken, ShadowToken, RadiusToken } from './token-extractor';

/**
 * Token file generation options
 */
export interface TokenFileOptions {
  /** Package/module name for generated code */
  packageName?: string;
  /** Enum/object name prefix */
  prefix?: string;
  /** Include comments/documentation */
  includeComments?: boolean;
  /** Generate preview code (SwiftUI Preview, Compose Preview) */
  includePreview?: boolean;
}

const DEFAULT_OPTIONS: TokenFileOptions = {
  packageName: 'com.designlibre.tokens',
  prefix: 'Design',
  includeComments: true,
  includePreview: false,
};

/**
 * Token file generation result
 */
export interface TokenFileResult {
  /** Generated code */
  code: string;
  /** File name */
  fileName: string;
  /** File extension */
  extension: string;
  /** Platform */
  platform: 'swiftui' | 'compose';
}

// ============================================================================
// SwiftUI Token Generation
// ============================================================================

/**
 * Generate SwiftUI token file (DesignTokens.swift)
 */
export function generateSwiftUITokens(
  tokens: ExtractedTokens,
  options: TokenFileOptions = {}
): TokenFileResult {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  const prefix = opts.prefix || 'Design';
  const lines: string[] = [];

  // Header
  if (opts.includeComments) {
    lines.push('//');
    lines.push('// DesignTokens.swift');
    lines.push('// Generated by DesignLibre');
    lines.push('//');
    lines.push('// Do not modify directly - regenerate from design file');
    lines.push('//');
    lines.push('');
  }

  lines.push('import SwiftUI');
  lines.push('');

  // Color extension for hex initialization
  lines.push('// MARK: - Color Extension');
  lines.push('extension Color {');
  lines.push('    init(hex: String) {');
  lines.push('        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)');
  lines.push('        var int: UInt64 = 0');
  lines.push('        Scanner(string: hex).scanHexInt64(&int)');
  lines.push('        let a, r, g, b: UInt64');
  lines.push('        switch hex.count {');
  lines.push('        case 3: // RGB (12-bit)');
  lines.push('            (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)');
  lines.push('        case 6: // RGB (24-bit)');
  lines.push('            (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)');
  lines.push('        case 8: // ARGB (32-bit)');
  lines.push('            (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)');
  lines.push('        default:');
  lines.push('            (a, r, g, b) = (255, 0, 0, 0)');
  lines.push('        }');
  lines.push('        self.init(');
  lines.push('            .sRGB,');
  lines.push('            red: Double(r) / 255,');
  lines.push('            green: Double(g) / 255,');
  lines.push('            blue: Double(b) / 255,');
  lines.push('            opacity: Double(a) / 255');
  lines.push('        )');
  lines.push('    }');
  lines.push('}');
  lines.push('');

  // Main tokens enum
  lines.push(`// MARK: - ${prefix}Tokens`);
  lines.push(`enum ${prefix}Tokens {`);

  // Colors
  if (tokens.colors.length > 0) {
    lines.push('');
    lines.push('    // MARK: Colors');
    lines.push('    enum Colors {');

    // Group colors by base name
    const colorGroups = groupColorsByName(tokens.colors);
    for (const [groupName, colors] of Object.entries(colorGroups)) {
      if (Object.keys(colors).length === 1 && colors['DEFAULT']) {
        // Single color, no shades
        const color = colors['DEFAULT']!;
        lines.push(`        static let ${sanitizeSwiftName(groupName)} = Color(hex: "${color.hex}")`);
      } else {
        // Multiple shades
        lines.push(`        enum ${capitalizeFirst(sanitizeSwiftName(groupName))} {`);
        for (const [shade, color] of Object.entries(colors)) {
          const propName = shade === 'DEFAULT' ? 'base' : `shade${shade}`;
          if (color.opacity < 1) {
            lines.push(`            static let ${propName} = Color(hex: "${color.hex}").opacity(${color.opacity.toFixed(2)})`);
          } else {
            lines.push(`            static let ${propName} = Color(hex: "${color.hex}")`);
          }
        }
        lines.push('        }');
      }
    }
    lines.push('    }');
  }

  // Spacing
  if (tokens.spacing.length > 0) {
    lines.push('');
    lines.push('    // MARK: Spacing');
    lines.push('    enum Spacing {');

    const spacingNames = ['xxs', 'xs', 'sm', 'md', 'lg', 'xl', 'xxl', 'xxxl'];
    tokens.spacing.forEach((space, i) => {
      const name = i < spacingNames.length ? spacingNames[i] : `space${i + 1}`;
      lines.push(`        static let ${name}: CGFloat = ${space.value}`);
    });
    lines.push('    }');
  }

  // Typography
  if (tokens.typography.length > 0) {
    lines.push('');
    lines.push('    // MARK: Typography');
    lines.push('    enum Typography {');

    for (const typo of tokens.typography) {
      const name = sanitizeSwiftName(typo.name.replace('text-', ''));
      const lineHeight = typo.lineHeight === 'auto' ? typo.fontSize * 1.5 : typo.lineHeight;
      lines.push(`        static let ${name} = Font.system(size: ${typo.fontSize}, weight: .${getFontWeightName(typo.fontWeight)})`);
      lines.push(`        static let ${name}LineHeight: CGFloat = ${lineHeight}`);
    }
    lines.push('    }');
  }

  // Border Radius
  if (tokens.radii.length > 0) {
    lines.push('');
    lines.push('    // MARK: Border Radius');
    lines.push('    enum Radius {');

    const radiusNames = ['sm', 'md', 'lg', 'xl', 'xxl', 'full'];
    tokens.radii.forEach((radius, i) => {
      const name = i < radiusNames.length ? radiusNames[i] : `radius${i + 1}`;
      lines.push(`        static let ${name}: CGFloat = ${radius.value}`);
    });
    lines.push('    }');
  }

  // Shadows
  if (tokens.shadows.length > 0) {
    lines.push('');
    lines.push('    // MARK: Shadows');
    lines.push('    enum Shadows {');

    for (const shadow of tokens.shadows) {
      const name = sanitizeSwiftName(shadow.name.replace('shadow-', '') || 'default');
      // Parse rgba color
      const colorMatch = shadow.color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
      if (colorMatch) {
        const r = parseInt(colorMatch[1]!) / 255;
        const g = parseInt(colorMatch[2]!) / 255;
        const b = parseInt(colorMatch[3]!) / 255;
        const a = colorMatch[4] ? parseFloat(colorMatch[4]) : 1;
        lines.push(`        static let ${name} = (color: Color(red: ${r.toFixed(3)}, green: ${g.toFixed(3)}, blue: ${b.toFixed(3)}).opacity(${a.toFixed(2)}), radius: CGFloat(${shadow.blur}), x: CGFloat(${shadow.x}), y: CGFloat(${shadow.y}))`);
      }
    }
    lines.push('    }');
  }

  lines.push('}');

  // Preview
  if (opts.includePreview) {
    lines.push('');
    lines.push('#if DEBUG');
    lines.push(`struct ${prefix}TokensPreview: PreviewProvider {`);
    lines.push('    static var previews: some View {');
    lines.push('        ScrollView {');
    lines.push('            VStack(alignment: .leading, spacing: 16) {');
    if (tokens.colors.length > 0) {
      lines.push('                Text("Colors").font(.headline)');
      lines.push(`                HStack { ForEach(0..<5) { _ in Rectangle().fill(${prefix}Tokens.Colors.${sanitizeSwiftName(tokens.colors[0]?.name.split('-')[0] || 'gray')}.shade500).frame(width: 40, height: 40) } }`);
    }
    lines.push('            }.padding()');
    lines.push('        }');
    lines.push('    }');
    lines.push('}');
    lines.push('#endif');
  }

  return {
    code: lines.join('\n'),
    fileName: `${prefix}Tokens`,
    extension: 'swift',
    platform: 'swiftui',
  };
}

// ============================================================================
// Compose Token Generation
// ============================================================================

/**
 * Generate Compose token file (Theme.kt)
 */
export function generateComposeTokens(
  tokens: ExtractedTokens,
  options: TokenFileOptions = {}
): TokenFileResult {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  const packageName = opts.packageName || 'com.designlibre.tokens';
  const prefix = opts.prefix || 'App';
  const lines: string[] = [];

  // Package and imports
  lines.push(`package ${packageName}`);
  lines.push('');

  if (opts.includeComments) {
    lines.push('/**');
    lines.push(' * Design Tokens');
    lines.push(' * Generated by DesignLibre');
    lines.push(' *');
    lines.push(' * Do not modify directly - regenerate from design file');
    lines.push(' */');
    lines.push('');
  }

  lines.push('import androidx.compose.ui.graphics.Color');
  lines.push('import androidx.compose.ui.unit.dp');
  lines.push('import androidx.compose.ui.unit.sp');
  lines.push('import androidx.compose.ui.text.TextStyle');
  lines.push('import androidx.compose.ui.text.font.FontWeight');
  lines.push('');

  // Main tokens object
  lines.push(`object ${prefix}Tokens {`);

  // Colors
  if (tokens.colors.length > 0) {
    lines.push('');
    lines.push('    // Colors');
    lines.push('    object Colors {');

    const colorGroups = groupColorsByName(tokens.colors);
    for (const [groupName, colors] of Object.entries(colorGroups)) {
      if (Object.keys(colors).length === 1 && colors['DEFAULT']) {
        const color = colors['DEFAULT']!;
        const hex = colorToComposeHex(color);
        lines.push(`        val ${sanitizeKotlinName(groupName)} = Color(0x${hex})`);
      } else {
        lines.push(`        object ${capitalizeFirst(sanitizeKotlinName(groupName))} {`);
        for (const [shade, color] of Object.entries(colors)) {
          const propName = shade === 'DEFAULT' ? 'base' : `shade${shade}`;
          const hex = colorToComposeHex(color);
          lines.push(`            val ${propName} = Color(0x${hex})`);
        }
        lines.push('        }');
      }
    }
    lines.push('    }');
  }

  // Spacing
  if (tokens.spacing.length > 0) {
    lines.push('');
    lines.push('    // Spacing');
    lines.push('    object Spacing {');

    const spacingNames = ['xxs', 'xs', 'sm', 'md', 'lg', 'xl', 'xxl', 'xxxl'];
    tokens.spacing.forEach((space, i) => {
      const name = i < spacingNames.length ? spacingNames[i] : `space${i + 1}`;
      lines.push(`        val ${name} = ${space.value}.dp`);
    });
    lines.push('    }');
  }

  // Typography
  if (tokens.typography.length > 0) {
    lines.push('');
    lines.push('    // Typography');
    lines.push('    object Typography {');

    for (const typo of tokens.typography) {
      const name = sanitizeKotlinName(typo.name.replace('text-', ''));
      const lineHeight = typo.lineHeight === 'auto' ? Math.round(typo.fontSize * 1.5) : typo.lineHeight;
      const fontWeight = getKotlinFontWeight(typo.fontWeight);
      lines.push(`        val ${name} = TextStyle(`);
      lines.push(`            fontSize = ${typo.fontSize}.sp,`);
      lines.push(`            fontWeight = FontWeight.${fontWeight},`);
      lines.push(`            lineHeight = ${lineHeight}.sp`);
      lines.push('        )');
    }
    lines.push('    }');
  }

  // Border Radius
  if (tokens.radii.length > 0) {
    lines.push('');
    lines.push('    // Border Radius');
    lines.push('    object Radius {');

    const radiusNames = ['sm', 'md', 'lg', 'xl', 'xxl', 'full'];
    tokens.radii.forEach((radius, i) => {
      const name = i < radiusNames.length ? radiusNames[i] : `radius${i + 1}`;
      lines.push(`        val ${name} = ${radius.value}.dp`);
    });
    lines.push('    }');
  }

  // Shadows (as elevation values)
  if (tokens.shadows.length > 0) {
    lines.push('');
    lines.push('    // Shadows (elevation)');
    lines.push('    object Elevation {');

    for (const shadow of tokens.shadows) {
      const name = sanitizeKotlinName(shadow.name.replace('shadow-', '') || 'default');
      // Use blur as approximate elevation
      lines.push(`        val ${name} = ${shadow.blur}.dp`);
    }
    lines.push('    }');
  }

  lines.push('}');

  return {
    code: lines.join('\n'),
    fileName: `${prefix}Tokens`,
    extension: 'kt',
    platform: 'compose',
  };
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Group colors by base name (e.g., "blue-500" -> { blue: { 500: color } })
 */
function groupColorsByName(colors: ColorToken[]): Record<string, Record<string, ColorToken>> {
  const groups: Record<string, Record<string, ColorToken>> = {};

  for (const color of colors) {
    const parts = color.name.split('-');
    let baseName: string;
    let shade: string;

    if (parts.length >= 2 && /^\d+$/.test(parts[parts.length - 1]!)) {
      baseName = parts.slice(0, -1).join('-');
      shade = parts[parts.length - 1]!;
    } else {
      baseName = color.name;
      shade = 'DEFAULT';
    }

    if (!groups[baseName]) {
      groups[baseName] = {};
    }
    groups[baseName]![shade] = color;
  }

  return groups;
}

/**
 * Convert color token to Compose hex format (AARRGGBB)
 */
function colorToComposeHex(color: ColorToken): string {
  const a = Math.round(color.opacity * 255).toString(16).padStart(2, '0').toUpperCase();
  const hex = color.hex.replace('#', '').toUpperCase();
  return `${a}${hex}`;
}

/**
 * Sanitize name for Swift
 */
function sanitizeSwiftName(name: string): string {
  // Remove invalid characters and convert to camelCase
  return name
    .replace(/[^a-zA-Z0-9]/g, '_')
    .replace(/_+/g, '_')
    .replace(/^_/, '')
    .replace(/_$/, '')
    .replace(/_([a-z])/g, (_, c) => c.toUpperCase())
    .replace(/^(\d)/, '_$1');
}

/**
 * Sanitize name for Kotlin
 */
function sanitizeKotlinName(name: string): string {
  return sanitizeSwiftName(name);
}

/**
 * Capitalize first letter
 */
function capitalizeFirst(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Get Swift font weight name
 */
function getFontWeightName(weight: number): string {
  if (weight <= 100) return 'ultraLight';
  if (weight <= 200) return 'thin';
  if (weight <= 300) return 'light';
  if (weight <= 400) return 'regular';
  if (weight <= 500) return 'medium';
  if (weight <= 600) return 'semibold';
  if (weight <= 700) return 'bold';
  if (weight <= 800) return 'heavy';
  return 'black';
}

/**
 * Get Kotlin font weight
 */
function getKotlinFontWeight(weight: number): string {
  if (weight <= 100) return 'Thin';
  if (weight <= 200) return 'ExtraLight';
  if (weight <= 300) return 'Light';
  if (weight <= 400) return 'Normal';
  if (weight <= 500) return 'Medium';
  if (weight <= 600) return 'SemiBold';
  if (weight <= 700) return 'Bold';
  if (weight <= 800) return 'ExtraBold';
  return 'Black';
}

// ============================================================================
// Exports
// ============================================================================

export type { ExtractedTokens, ColorToken, SpacingToken, TypographyToken, ShadowToken, RadiusToken };
