/**
 * iOS Code Generator
 *
 * Generate Swift and Objective-C code from scene graph nodes.
 */
/**
 * iOS Code Generator
 */
export class IOSCodeGenerator {
    sceneGraph;
    colorIndex = 0;
    extractedColors = new Map();
    constructor(sceneGraph) {
        this.sceneGraph = sceneGraph;
    }
    /**
     * Generate iOS code for a node.
     */
    generate(nodeId, options = {}) {
        const language = options.language ?? 'swift';
        const framework = options.framework ?? (language === 'swift' ? 'swiftui' : 'uikit');
        const prefix = options.prefix ?? '';
        const includePreview = options.includePreview ?? true;
        const useColorExtension = options.useColorExtension ?? true;
        const includeComments = options.includeComments ?? true;
        // Reset extraction state
        this.colorIndex = 0;
        this.extractedColors.clear();
        // Extract colors first
        this.extractColors(nodeId);
        const node = this.sceneGraph.getNode(nodeId);
        if (!node) {
            throw new Error(`Node not found: ${nodeId}`);
        }
        let code;
        let colorExtension;
        if (language === 'swift') {
            if (framework === 'swiftui') {
                code = this.generateSwiftUI(nodeId, prefix, includePreview, includeComments);
                colorExtension = useColorExtension ? this.generateSwiftColorExtension() : '';
            }
            else {
                code = this.generateUIKit(nodeId, prefix, includeComments);
                colorExtension = useColorExtension ? this.generateUIKitColorExtension() : '';
            }
        }
        else {
            code = this.generateObjC(nodeId, prefix, includeComments);
            colorExtension = useColorExtension ? this.generateObjCColorExtension() : '';
        }
        const ext = language === 'swift' ? 'swift' : 'm';
        const blob = new Blob([code], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        return {
            code,
            colorExtension,
            extension: ext,
            blob,
            url,
        };
    }
    /**
     * Download the generated code.
     */
    download(nodeId, filename, options = {}) {
        const result = this.generate(nodeId, options);
        const ext = result.extension;
        const finalFilename = filename ?? `DesignLibreView.${ext}`;
        const link = document.createElement('a');
        link.href = result.url;
        link.download = finalFilename;
        link.click();
        URL.revokeObjectURL(result.url);
    }
    // =========================================================================
    // Swift/SwiftUI Generation
    // =========================================================================
    generateSwiftUI(nodeId, prefix, includePreview, includeComments) {
        const node = this.sceneGraph.getNode(nodeId);
        if (!node)
            return '';
        const structName = `${prefix}${this.sanitizeName(node.name || node.type)}View`;
        const parts = [];
        // Header comment
        if (includeComments) {
            parts.push('// Generated by DesignLibre');
            parts.push('// Do not modify directly');
            parts.push('');
        }
        parts.push('import SwiftUI');
        parts.push('');
        // Main struct
        parts.push(`struct ${structName}: View {`);
        parts.push('    var body: some View {');
        parts.push(this.generateSwiftUIBody(nodeId, 8));
        parts.push('    }');
        parts.push('}');
        // Preview provider
        if (includePreview) {
            parts.push('');
            parts.push(`#Preview {`);
            parts.push(`    ${structName}()`);
            parts.push('}');
        }
        return parts.join('\n');
    }
    generateSwiftUIBody(nodeId, indent) {
        const node = this.sceneGraph.getNode(nodeId);
        if (!node)
            return '';
        const spaces = ' '.repeat(indent);
        const parts = [];
        switch (node.type) {
            case 'FRAME':
                parts.push(this.generateSwiftUIFrame(node, nodeId, indent));
                break;
            case 'VECTOR':
                parts.push(this.generateSwiftUIVector(node, indent));
                break;
            case 'TEXT':
                parts.push(this.generateSwiftUIText(node, indent));
                break;
            case 'GROUP':
                parts.push(this.generateSwiftUIGroup(nodeId, indent));
                break;
            default:
                // Generic container
                parts.push(`${spaces}EmptyView()`);
        }
        return parts.join('\n');
    }
    generateSwiftUIFrame(node, nodeId, indent) {
        const spaces = ' '.repeat(indent);
        const parts = [];
        const childIds = this.sceneGraph.getChildIds(nodeId);
        const hasChildren = childIds.length > 0;
        // Determine layout
        const isHorizontal = node.autoLayout?.mode === 'HORIZONTAL';
        const isVertical = node.autoLayout?.mode === 'VERTICAL';
        if (hasChildren) {
            if (isHorizontal) {
                parts.push(`${spaces}HStack(spacing: ${node.autoLayout?.itemSpacing ?? 0}) {`);
            }
            else if (isVertical) {
                parts.push(`${spaces}VStack(spacing: ${node.autoLayout?.itemSpacing ?? 0}) {`);
            }
            else {
                parts.push(`${spaces}ZStack {`);
            }
            for (const childId of childIds) {
                parts.push(this.generateSwiftUIBody(childId, indent + 4));
            }
            parts.push(`${spaces}}`);
        }
        else {
            parts.push(`${spaces}Rectangle()`);
        }
        // Apply modifiers
        const modifiers = this.generateSwiftUIModifiers(node, indent);
        if (modifiers) {
            parts.push(modifiers);
        }
        return parts.join('\n');
    }
    generateSwiftUIVector(node, indent) {
        const spaces = ' '.repeat(indent);
        const parts = [];
        const path = node.vectorPaths?.[0];
        if (path) {
            parts.push(`${spaces}Path { path in`);
            parts.push(this.generateSwiftUIPathCommands(path, indent + 4));
            parts.push(`${spaces}}`);
            // Apply fill
            const fill = this.getFirstSolidFill(node.fills);
            if (fill) {
                const colorName = this.getColorName(fill);
                parts.push(`${spaces}.fill(Color.${colorName})`);
            }
            // Apply stroke
            const stroke = this.getFirstSolidStroke(node.strokes);
            if (stroke) {
                const colorName = this.getColorName(stroke);
                parts.push(`${spaces}.stroke(Color.${colorName}, lineWidth: ${node.strokeWeight ?? 1})`);
            }
        }
        return parts.join('\n');
    }
    generateSwiftUIPathCommands(path, indent) {
        const spaces = ' '.repeat(indent);
        const parts = [];
        for (const cmd of path.commands) {
            switch (cmd.type) {
                case 'M':
                    parts.push(`${spaces}path.move(to: CGPoint(x: ${cmd.x}, y: ${cmd.y}))`);
                    break;
                case 'L':
                    parts.push(`${spaces}path.addLine(to: CGPoint(x: ${cmd.x}, y: ${cmd.y}))`);
                    break;
                case 'C':
                    parts.push(`${spaces}path.addCurve(`);
                    parts.push(`${spaces}    to: CGPoint(x: ${cmd.x}, y: ${cmd.y}),`);
                    parts.push(`${spaces}    control1: CGPoint(x: ${cmd.x1}, y: ${cmd.y1}),`);
                    parts.push(`${spaces}    control2: CGPoint(x: ${cmd.x2}, y: ${cmd.y2})`);
                    parts.push(`${spaces})`);
                    break;
                case 'Z':
                    parts.push(`${spaces}path.closeSubpath()`);
                    break;
            }
        }
        return parts.join('\n');
    }
    generateSwiftUIText(node, indent) {
        const spaces = ' '.repeat(indent);
        const parts = [];
        const firstStyle = node.textStyles[0];
        const fontSize = firstStyle?.fontSize ?? 16;
        const fontWeight = this.swiftFontWeight(firstStyle?.fontWeight ?? 400);
        parts.push(`${spaces}Text("${this.escapeString(node.characters)}")`);
        parts.push(`${spaces}    .font(.system(size: ${fontSize}, weight: .${fontWeight}))`);
        // Text color
        const fill = this.getFirstSolidFill(node.fills);
        if (fill) {
            const colorName = this.getColorName(fill);
            parts.push(`${spaces}    .foregroundColor(Color.${colorName})`);
        }
        return parts.join('\n');
    }
    generateSwiftUIGroup(nodeId, indent) {
        const spaces = ' '.repeat(indent);
        const parts = [];
        const childIds = this.sceneGraph.getChildIds(nodeId);
        parts.push(`${spaces}Group {`);
        for (const childId of childIds) {
            parts.push(this.generateSwiftUIBody(childId, indent + 4));
        }
        parts.push(`${spaces}}`);
        return parts.join('\n');
    }
    generateSwiftUIModifiers(node, indent) {
        const spaces = ' '.repeat(indent);
        const parts = [];
        // Frame size
        if ('width' in node && 'height' in node) {
            const n = node;
            parts.push(`${spaces}.frame(width: ${n.width}, height: ${n.height})`);
        }
        // Background
        if ('fills' in node) {
            const fill = this.getFirstSolidFill(node.fills);
            if (fill) {
                const colorName = this.getColorName(fill);
                parts.push(`${spaces}.background(Color.${colorName})`);
            }
        }
        // Corner radius
        if ('cornerRadius' in node) {
            const radius = node.cornerRadius;
            if (radius > 0) {
                parts.push(`${spaces}.cornerRadius(${radius})`);
            }
        }
        // Opacity
        if ('opacity' in node) {
            const opacity = node.opacity;
            if (opacity !== 1) {
                parts.push(`${spaces}.opacity(${opacity})`);
            }
        }
        // Rotation
        if ('rotation' in node) {
            const rotation = node.rotation;
            if (rotation && rotation !== 0) {
                parts.push(`${spaces}.rotationEffect(.degrees(${rotation}))`);
            }
        }
        // Shadow effects
        if ('effects' in node) {
            const effects = node.effects ?? [];
            for (const effect of effects) {
                const e = effect;
                if (e.type === 'DROP_SHADOW' && e.visible !== false && e.color) {
                    const colorName = this.getColorName(e.color);
                    parts.push(`${spaces}.shadow(color: Color.${colorName}, radius: ${e.radius ?? 0}, x: ${e.offset?.x ?? 0}, y: ${e.offset?.y ?? 0})`);
                }
            }
        }
        return parts.join('\n');
    }
    // =========================================================================
    // UIKit Generation
    // =========================================================================
    generateUIKit(nodeId, prefix, includeComments) {
        const node = this.sceneGraph.getNode(nodeId);
        if (!node)
            return '';
        const className = `${prefix}${this.sanitizeName(node.name || node.type)}View`;
        const parts = [];
        if (includeComments) {
            parts.push('// Generated by DesignLibre');
            parts.push('// Do not modify directly');
            parts.push('');
        }
        parts.push('import UIKit');
        parts.push('');
        parts.push(`class ${className}: UIView {`);
        parts.push('');
        parts.push('    override init(frame: CGRect) {');
        parts.push('        super.init(frame: frame)');
        parts.push('        setupView()');
        parts.push('    }');
        parts.push('');
        parts.push('    required init?(coder: NSCoder) {');
        parts.push('        super.init(coder: coder)');
        parts.push('        setupView()');
        parts.push('    }');
        parts.push('');
        parts.push('    private func setupView() {');
        parts.push(this.generateUIKitSetup(nodeId, 8));
        parts.push('    }');
        parts.push('}');
        return parts.join('\n');
    }
    generateUIKitSetup(nodeId, indent) {
        const node = this.sceneGraph.getNode(nodeId);
        if (!node)
            return '';
        const spaces = ' '.repeat(indent);
        const parts = [];
        // Background color
        if ('fills' in node) {
            const fill = this.getFirstSolidFill(node.fills);
            if (fill) {
                const colorName = this.getColorName(fill);
                parts.push(`${spaces}backgroundColor = UIColor.${colorName}`);
            }
        }
        // Corner radius
        if ('cornerRadius' in node) {
            const radius = node.cornerRadius;
            if (radius > 0) {
                parts.push(`${spaces}layer.cornerRadius = ${radius}`);
                parts.push(`${spaces}clipsToBounds = true`);
            }
        }
        // Opacity
        if ('opacity' in node) {
            const opacity = node.opacity;
            if (opacity !== 1) {
                parts.push(`${spaces}alpha = ${opacity}`);
            }
        }
        // Shadow
        if ('effects' in node) {
            const effects = node.effects ?? [];
            for (const effect of effects) {
                const e = effect;
                if (e.type === 'DROP_SHADOW' && e.visible !== false && e.color) {
                    const colorName = this.getColorName(e.color);
                    parts.push(`${spaces}layer.shadowColor = UIColor.${colorName}.cgColor`);
                    parts.push(`${spaces}layer.shadowOffset = CGSize(width: ${e.offset?.x ?? 0}, height: ${e.offset?.y ?? 0})`);
                    parts.push(`${spaces}layer.shadowRadius = ${e.radius ?? 0}`);
                    parts.push(`${spaces}layer.shadowOpacity = 1.0`);
                }
            }
        }
        // Add child views
        const childIds = this.sceneGraph.getChildIds(nodeId);
        for (let i = 0; i < childIds.length; i++) {
            const childId = childIds[i];
            const childNode = this.sceneGraph.getNode(childId);
            if (!childNode)
                continue;
            parts.push('');
            parts.push(`${spaces}// Child: ${childNode.name || childNode.type}`);
            parts.push(`${spaces}let child${i} = UIView()`);
            parts.push(this.generateUIKitChildSetup(childId, `child${i}`, indent));
            parts.push(`${spaces}addSubview(child${i})`);
        }
        return parts.join('\n');
    }
    generateUIKitChildSetup(nodeId, varName, indent) {
        const node = this.sceneGraph.getNode(nodeId);
        if (!node)
            return '';
        const spaces = ' '.repeat(indent);
        const parts = [];
        // Position and size
        if ('x' in node && 'y' in node && 'width' in node && 'height' in node) {
            const n = node;
            parts.push(`${spaces}${varName}.frame = CGRect(x: ${n.x}, y: ${n.y}, width: ${n.width}, height: ${n.height})`);
        }
        // Background color
        if ('fills' in node) {
            const fill = this.getFirstSolidFill(node.fills);
            if (fill) {
                const colorName = this.getColorName(fill);
                parts.push(`${spaces}${varName}.backgroundColor = UIColor.${colorName}`);
            }
        }
        // Corner radius
        if ('cornerRadius' in node) {
            const radius = node.cornerRadius;
            if (radius > 0) {
                parts.push(`${spaces}${varName}.layer.cornerRadius = ${radius}`);
            }
        }
        return parts.join('\n');
    }
    // =========================================================================
    // Objective-C Generation
    // =========================================================================
    generateObjC(nodeId, prefix, includeComments) {
        const node = this.sceneGraph.getNode(nodeId);
        if (!node)
            return '';
        const className = `${prefix}${this.sanitizeName(node.name || node.type)}View`;
        const parts = [];
        if (includeComments) {
            parts.push('// Generated by DesignLibre');
            parts.push('// Do not modify directly');
            parts.push('');
        }
        // Header
        parts.push('#import <UIKit/UIKit.h>');
        parts.push('');
        parts.push(`@interface ${className} : UIView`);
        parts.push('@end');
        parts.push('');
        // Implementation
        parts.push(`@implementation ${className}`);
        parts.push('');
        parts.push('- (instancetype)initWithFrame:(CGRect)frame {');
        parts.push('    self = [super initWithFrame:frame];');
        parts.push('    if (self) {');
        parts.push('        [self setupView];');
        parts.push('    }');
        parts.push('    return self;');
        parts.push('}');
        parts.push('');
        parts.push('- (instancetype)initWithCoder:(NSCoder *)coder {');
        parts.push('    self = [super initWithCoder:coder];');
        parts.push('    if (self) {');
        parts.push('        [self setupView];');
        parts.push('    }');
        parts.push('    return self;');
        parts.push('}');
        parts.push('');
        parts.push('- (void)setupView {');
        parts.push(this.generateObjCSetup(nodeId, 4));
        parts.push('}');
        parts.push('');
        parts.push('@end');
        return parts.join('\n');
    }
    generateObjCSetup(nodeId, indent) {
        const node = this.sceneGraph.getNode(nodeId);
        if (!node)
            return '';
        const spaces = ' '.repeat(indent);
        const parts = [];
        // Background color
        if ('fills' in node) {
            const fill = this.getFirstSolidFill(node.fills);
            if (fill) {
                parts.push(`${spaces}self.backgroundColor = [UIColor colorWithRed:${fill.r.toFixed(3)} green:${fill.g.toFixed(3)} blue:${fill.b.toFixed(3)} alpha:${fill.a.toFixed(3)}];`);
            }
        }
        // Corner radius
        if ('cornerRadius' in node) {
            const radius = node.cornerRadius;
            if (radius > 0) {
                parts.push(`${spaces}self.layer.cornerRadius = ${radius};`);
                parts.push(`${spaces}self.clipsToBounds = YES;`);
            }
        }
        // Opacity
        if ('opacity' in node) {
            const opacity = node.opacity;
            if (opacity !== 1) {
                parts.push(`${spaces}self.alpha = ${opacity};`);
            }
        }
        return parts.join('\n');
    }
    // =========================================================================
    // Color Extension Generation
    // =========================================================================
    generateSwiftColorExtension() {
        const parts = [];
        parts.push('import SwiftUI');
        parts.push('');
        parts.push('extension Color {');
        for (const [_key, color] of this.extractedColors) {
            const { r, g, b, a } = color.rgba;
            parts.push(`    static let ${color.name} = Color(red: ${r.toFixed(3)}, green: ${g.toFixed(3)}, blue: ${b.toFixed(3)}, opacity: ${a.toFixed(3)})`);
        }
        parts.push('}');
        return parts.join('\n');
    }
    generateUIKitColorExtension() {
        const parts = [];
        parts.push('import UIKit');
        parts.push('');
        parts.push('extension UIColor {');
        for (const [_key, color] of this.extractedColors) {
            const { r, g, b, a } = color.rgba;
            parts.push(`    static let ${color.name} = UIColor(red: ${r.toFixed(3)}, green: ${g.toFixed(3)}, blue: ${b.toFixed(3)}, alpha: ${a.toFixed(3)})`);
        }
        parts.push('}');
        return parts.join('\n');
    }
    generateObjCColorExtension() {
        const parts = [];
        parts.push('#import <UIKit/UIKit.h>');
        parts.push('');
        parts.push('@interface UIColor (DesignLibreColors)');
        for (const [_key, color] of this.extractedColors) {
            parts.push(`+ (UIColor *)${color.name};`);
        }
        parts.push('@end');
        parts.push('');
        parts.push('@implementation UIColor (DesignLibreColors)');
        for (const [_key, color] of this.extractedColors) {
            const { r, g, b, a } = color.rgba;
            parts.push(`+ (UIColor *)${color.name} {`);
            parts.push(`    return [UIColor colorWithRed:${r.toFixed(3)} green:${g.toFixed(3)} blue:${b.toFixed(3)} alpha:${a.toFixed(3)}];`);
            parts.push('}');
        }
        parts.push('@end');
        return parts.join('\n');
    }
    // =========================================================================
    // Helper Methods
    // =========================================================================
    extractColors(nodeId) {
        const node = this.sceneGraph.getNode(nodeId);
        if (!node)
            return;
        if ('fills' in node) {
            const fills = node.fills ?? [];
            for (const fill of fills) {
                if (fill.type === 'SOLID' && fill.visible !== false && fill.color) {
                    this.registerColor(fill.color);
                }
            }
        }
        if ('strokes' in node) {
            const strokes = node.strokes ?? [];
            for (const stroke of strokes) {
                if (stroke.type === 'SOLID' && stroke.visible !== false && stroke.color) {
                    this.registerColor(stroke.color);
                }
            }
        }
        if ('effects' in node) {
            const effects = node.effects ?? [];
            for (const effect of effects) {
                const e = effect;
                if (e.color) {
                    this.registerColor(e.color);
                }
            }
        }
        const childIds = this.sceneGraph.getChildIds(nodeId);
        for (const childId of childIds) {
            this.extractColors(childId);
        }
    }
    registerColor(color) {
        const key = this.colorToKey(color);
        if (!this.extractedColors.has(key)) {
            const name = `designLibreColor${++this.colorIndex}`;
            this.extractedColors.set(key, { name, rgba: color });
        }
        return this.extractedColors.get(key).name;
    }
    getColorName(color) {
        const key = this.colorToKey(color);
        return this.extractedColors.get(key)?.name ?? 'clear';
    }
    colorToKey(color) {
        return `${color.r.toFixed(3)}-${color.g.toFixed(3)}-${color.b.toFixed(3)}-${color.a.toFixed(3)}`;
    }
    getFirstSolidFill(fills) {
        if (!fills)
            return null;
        const solid = fills.find(f => f.type === 'SOLID' && f.visible !== false);
        return solid?.color ?? null;
    }
    getFirstSolidStroke(strokes) {
        if (!strokes)
            return null;
        const solid = strokes.find(s => s.type === 'SOLID' && s.visible !== false);
        return solid?.color ?? null;
    }
    swiftFontWeight(weight) {
        if (weight <= 100)
            return 'ultraLight';
        if (weight <= 200)
            return 'thin';
        if (weight <= 300)
            return 'light';
        if (weight <= 400)
            return 'regular';
        if (weight <= 500)
            return 'medium';
        if (weight <= 600)
            return 'semibold';
        if (weight <= 700)
            return 'bold';
        if (weight <= 800)
            return 'heavy';
        return 'black';
    }
    sanitizeName(name) {
        return name
            .replace(/[^a-zA-Z0-9]/g, '')
            .replace(/^(\d)/, '_$1');
    }
    escapeString(str) {
        return str
            .replace(/\\/g, '\\\\')
            .replace(/"/g, '\\"')
            .replace(/\n/g, '\\n');
    }
}
/**
 * Create an iOS code generator.
 */
export function createIOSCodeGenerator(sceneGraph) {
    return new IOSCodeGenerator(sceneGraph);
}
//# sourceMappingURL=ios-code-generator.js.map