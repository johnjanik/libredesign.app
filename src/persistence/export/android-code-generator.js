/**
 * Android Code Generator
 *
 * Generate Kotlin and Java code from scene graph nodes.
 */
/**
 * Android Code Generator
 */
export class AndroidCodeGenerator {
    sceneGraph;
    colorIndex = 0;
    dimenIndex = 0;
    extractedColors = new Map();
    extractedDimens = new Map();
    constructor(sceneGraph) {
        this.sceneGraph = sceneGraph;
    }
    /**
     * Generate Android code for a node.
     */
    generate(nodeId, options = {}) {
        const language = options.language ?? 'kotlin';
        const framework = options.framework ?? (language === 'kotlin' ? 'compose' : 'view');
        const packageName = options.packageName ?? 'com.designlibre.generated';
        const prefix = options.prefix ?? '';
        const includePreview = options.includePreview ?? true;
        const generateColorsXml = options.generateColorsXml ?? true;
        const includeComments = options.includeComments ?? true;
        // Reset extraction state
        this.colorIndex = 0;
        this.dimenIndex = 0;
        this.extractedColors.clear();
        this.extractedDimens.clear();
        // Extract design tokens first
        this.extractDesignTokens(nodeId);
        const node = this.sceneGraph.getNode(nodeId);
        if (!node) {
            throw new Error(`Node not found: ${nodeId}`);
        }
        let code;
        if (language === 'kotlin') {
            if (framework === 'compose') {
                code = this.generateCompose(nodeId, packageName, prefix, includePreview, includeComments);
            }
            else {
                code = this.generateKotlinView(nodeId, packageName, prefix, includeComments);
            }
        }
        else {
            code = this.generateJavaView(nodeId, packageName, prefix, includeComments);
        }
        const colorsXml = generateColorsXml ? this.generateColorsXml() : '';
        const dimensXml = this.generateDimensXml();
        const ext = language === 'kotlin' ? 'kt' : 'java';
        const blob = new Blob([code], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        return {
            code,
            colorsXml,
            dimensXml,
            extension: ext,
            blob,
            url,
        };
    }
    /**
     * Download the generated code.
     */
    download(nodeId, filename, options = {}) {
        const result = this.generate(nodeId, options);
        const ext = result.extension;
        const finalFilename = filename ?? `DesignLibreView.${ext}`;
        const link = document.createElement('a');
        link.href = result.url;
        link.download = finalFilename;
        link.click();
        URL.revokeObjectURL(result.url);
    }
    // =========================================================================
    // Jetpack Compose Generation
    // =========================================================================
    generateCompose(nodeId, packageName, prefix, includePreview, includeComments) {
        const node = this.sceneGraph.getNode(nodeId);
        if (!node)
            return '';
        const funcName = `${prefix}${this.sanitizeName(node.name || node.type)}Screen`;
        const parts = [];
        // Package and imports
        parts.push(`package ${packageName}`);
        parts.push('');
        if (includeComments) {
            parts.push('// Generated by DesignLibre');
            parts.push('// Do not modify directly');
            parts.push('');
        }
        parts.push('import androidx.compose.foundation.background');
        parts.push('import androidx.compose.foundation.layout.*');
        parts.push('import androidx.compose.foundation.shape.RoundedCornerShape');
        parts.push('import androidx.compose.material3.Text');
        parts.push('import androidx.compose.runtime.Composable');
        parts.push('import androidx.compose.ui.Alignment');
        parts.push('import androidx.compose.ui.Modifier');
        parts.push('import androidx.compose.ui.draw.clip');
        parts.push('import androidx.compose.ui.draw.rotate');
        parts.push('import androidx.compose.ui.draw.shadow');
        parts.push('import androidx.compose.ui.graphics.Color');
        parts.push('import androidx.compose.ui.graphics.Path');
        parts.push('import androidx.compose.ui.graphics.drawscope.Fill');
        parts.push('import androidx.compose.ui.text.font.FontWeight');
        parts.push('import androidx.compose.ui.tooling.preview.Preview');
        parts.push('import androidx.compose.ui.unit.dp');
        parts.push('import androidx.compose.ui.unit.sp');
        parts.push('');
        // Color constants
        parts.push('// Color Palette');
        for (const [, color] of this.extractedColors) {
            const hex = this.rgbaToHex(color.rgba);
            parts.push(`private val ${color.name} = Color(0x${hex})`);
        }
        parts.push('');
        // Main composable
        parts.push('@Composable');
        parts.push(`fun ${funcName}() {`);
        parts.push(this.generateComposeBody(nodeId, 4));
        parts.push('}');
        // Preview
        if (includePreview) {
            parts.push('');
            parts.push('@Preview(showBackground = true)');
            parts.push('@Composable');
            parts.push(`fun ${funcName}Preview() {`);
            parts.push(`    ${funcName}()`);
            parts.push('}');
        }
        return parts.join('\n');
    }
    generateComposeBody(nodeId, indent) {
        const node = this.sceneGraph.getNode(nodeId);
        if (!node)
            return '';
        const spaces = ' '.repeat(indent);
        const parts = [];
        switch (node.type) {
            case 'FRAME':
                parts.push(this.generateComposeFrame(node, nodeId, indent));
                break;
            case 'VECTOR':
                parts.push(this.generateComposeVector(node, indent));
                break;
            case 'TEXT':
                parts.push(this.generateComposeText(node, indent));
                break;
            case 'GROUP':
                parts.push(this.generateComposeGroup(nodeId, indent));
                break;
            default:
                parts.push(`${spaces}Box {}`);
        }
        return parts.join('\n');
    }
    generateComposeFrame(node, nodeId, indent) {
        const spaces = ' '.repeat(indent);
        const parts = [];
        const childIds = this.sceneGraph.getChildIds(nodeId);
        const hasChildren = childIds.length > 0;
        // Determine layout
        const isHorizontal = node.autoLayout?.mode === 'HORIZONTAL';
        const isVertical = node.autoLayout?.mode === 'VERTICAL';
        // Build modifier chain
        const modifiers = this.generateComposeModifiers(node, indent + 4);
        if (hasChildren) {
            if (isHorizontal) {
                const spacing = node.autoLayout?.itemSpacing ?? 0;
                parts.push(`${spaces}Row(`);
                parts.push(`${spaces}    modifier = ${modifiers},`);
                parts.push(`${spaces}    horizontalArrangement = Arrangement.spacedBy(${spacing}.dp)`);
                parts.push(`${spaces}) {`);
            }
            else if (isVertical) {
                const spacing = node.autoLayout?.itemSpacing ?? 0;
                parts.push(`${spaces}Column(`);
                parts.push(`${spaces}    modifier = ${modifiers},`);
                parts.push(`${spaces}    verticalArrangement = Arrangement.spacedBy(${spacing}.dp)`);
                parts.push(`${spaces}) {`);
            }
            else {
                parts.push(`${spaces}Box(`);
                parts.push(`${spaces}    modifier = ${modifiers}`);
                parts.push(`${spaces}) {`);
            }
            for (const childId of childIds) {
                parts.push(this.generateComposeBody(childId, indent + 4));
            }
            parts.push(`${spaces}}`);
        }
        else {
            parts.push(`${spaces}Box(`);
            parts.push(`${spaces}    modifier = ${modifiers}`);
            parts.push(`${spaces}) {}`);
        }
        return parts.join('\n');
    }
    generateComposeVector(node, indent) {
        const spaces = ' '.repeat(indent);
        const parts = [];
        const path = node.vectorPaths?.[0];
        if (!path) {
            return `${spaces}Box {}`;
        }
        parts.push(`${spaces}Canvas(`);
        parts.push(`${spaces}    modifier = Modifier.size(${node.width}.dp, ${node.height}.dp)`);
        parts.push(`${spaces}) {`);
        parts.push(`${spaces}    val path = Path().apply {`);
        for (const cmd of path.commands) {
            switch (cmd.type) {
                case 'M':
                    parts.push(`${spaces}        moveTo(${cmd.x}f, ${cmd.y}f)`);
                    break;
                case 'L':
                    parts.push(`${spaces}        lineTo(${cmd.x}f, ${cmd.y}f)`);
                    break;
                case 'C':
                    parts.push(`${spaces}        cubicTo(${cmd.x1}f, ${cmd.y1}f, ${cmd.x2}f, ${cmd.y2}f, ${cmd.x}f, ${cmd.y}f)`);
                    break;
                case 'Z':
                    parts.push(`${spaces}        close()`);
                    break;
            }
        }
        parts.push(`${spaces}    }`);
        const fill = this.getFirstSolidFill(node.fills);
        if (fill) {
            const colorName = this.getColorName(fill);
            parts.push(`${spaces}    drawPath(path, color = ${colorName})`);
        }
        parts.push(`${spaces}}`);
        return parts.join('\n');
    }
    generateComposeText(node, indent) {
        const spaces = ' '.repeat(indent);
        const parts = [];
        const firstStyle = node.textStyles[0];
        const fontSize = firstStyle?.fontSize ?? 16;
        const fontWeight = this.kotlinFontWeight(firstStyle?.fontWeight ?? 400);
        const fill = this.getFirstSolidFill(node.fills);
        const colorName = fill ? this.getColorName(fill) : 'Color.Black';
        parts.push(`${spaces}Text(`);
        parts.push(`${spaces}    text = "${this.escapeString(node.characters)}",`);
        parts.push(`${spaces}    fontSize = ${fontSize}.sp,`);
        parts.push(`${spaces}    fontWeight = FontWeight.${fontWeight},`);
        parts.push(`${spaces}    color = ${colorName}`);
        parts.push(`${spaces})`);
        return parts.join('\n');
    }
    generateComposeGroup(nodeId, indent) {
        const spaces = ' '.repeat(indent);
        const parts = [];
        const childIds = this.sceneGraph.getChildIds(nodeId);
        parts.push(`${spaces}Box {`);
        for (const childId of childIds) {
            parts.push(this.generateComposeBody(childId, indent + 4));
        }
        parts.push(`${spaces}}`);
        return parts.join('\n');
    }
    generateComposeModifiers(node, indent) {
        const parts = ['Modifier'];
        // Size
        if ('width' in node && 'height' in node) {
            const n = node;
            parts.push(`.size(${n.width}.dp, ${n.height}.dp)`);
        }
        // Background
        if ('fills' in node) {
            const fill = this.getFirstSolidFill(node.fills);
            if (fill) {
                const colorName = this.getColorName(fill);
                parts.push(`.background(${colorName})`);
            }
        }
        // Corner radius
        if ('cornerRadius' in node) {
            const radius = node.cornerRadius;
            if (radius > 0) {
                parts.push(`.clip(RoundedCornerShape(${radius}.dp))`);
            }
        }
        // Rotation
        if ('rotation' in node) {
            const rotation = node.rotation;
            if (rotation && rotation !== 0) {
                parts.push(`.rotate(${rotation}f)`);
            }
        }
        // Shadow
        if ('effects' in node) {
            const effects = node.effects ?? [];
            for (const effect of effects) {
                const e = effect;
                if (e.type === 'DROP_SHADOW' && e.visible !== false) {
                    parts.push(`.shadow(elevation = ${e.radius ?? 4}.dp)`);
                    break;
                }
            }
        }
        return parts.join('\n' + ' '.repeat(indent));
    }
    // =========================================================================
    // Kotlin View Generation
    // =========================================================================
    generateKotlinView(nodeId, packageName, prefix, includeComments) {
        const node = this.sceneGraph.getNode(nodeId);
        if (!node)
            return '';
        const className = `${prefix}${this.sanitizeName(node.name || node.type)}View`;
        const parts = [];
        parts.push(`package ${packageName}`);
        parts.push('');
        if (includeComments) {
            parts.push('// Generated by DesignLibre');
            parts.push('// Do not modify directly');
            parts.push('');
        }
        parts.push('import android.content.Context');
        parts.push('import android.graphics.Color');
        parts.push('import android.util.AttributeSet');
        parts.push('import android.view.View');
        parts.push('import android.widget.FrameLayout');
        parts.push('import android.widget.LinearLayout');
        parts.push('import android.widget.TextView');
        parts.push('');
        parts.push(`class ${className} @JvmOverloads constructor(`);
        parts.push('    context: Context,');
        parts.push('    attrs: AttributeSet? = null,');
        parts.push('    defStyleAttr: Int = 0');
        parts.push(') : FrameLayout(context, attrs, defStyleAttr) {');
        parts.push('');
        parts.push('    init {');
        parts.push('        setupView()');
        parts.push('    }');
        parts.push('');
        parts.push('    private fun setupView() {');
        parts.push(this.generateKotlinViewSetup(nodeId, 8));
        parts.push('    }');
        parts.push('}');
        return parts.join('\n');
    }
    generateKotlinViewSetup(nodeId, indent) {
        const node = this.sceneGraph.getNode(nodeId);
        if (!node)
            return '';
        const spaces = ' '.repeat(indent);
        const parts = [];
        // Background color
        if ('fills' in node) {
            const fill = this.getFirstSolidFill(node.fills);
            if (fill) {
                const hex = this.rgbaToHex(fill);
                parts.push(`${spaces}setBackgroundColor(Color.parseColor("#${hex}"))`);
            }
        }
        // Add children
        const childIds = this.sceneGraph.getChildIds(nodeId);
        for (let i = 0; i < childIds.length; i++) {
            const childId = childIds[i];
            const childNode = this.sceneGraph.getNode(childId);
            if (!childNode)
                continue;
            parts.push('');
            parts.push(`${spaces}// Child: ${childNode.name || childNode.type}`);
            parts.push(`${spaces}val child${i} = View(context).apply {`);
            parts.push(this.generateKotlinChildSetup(childId, indent + 4));
            parts.push(`${spaces}}`);
            parts.push(`${spaces}addView(child${i})`);
        }
        return parts.join('\n');
    }
    generateKotlinChildSetup(nodeId, indent) {
        const node = this.sceneGraph.getNode(nodeId);
        if (!node)
            return '';
        const spaces = ' '.repeat(indent);
        const parts = [];
        // Layout params
        if ('width' in node && 'height' in node) {
            const n = node;
            const w = Math.round(n.width);
            const h = Math.round(n.height);
            parts.push(`${spaces}layoutParams = FrameLayout.LayoutParams(${w}.dpToPx(), ${h}.dpToPx())`);
            if (n.x !== undefined && n.y !== undefined) {
                parts.push(`${spaces}x = ${n.x}f`);
                parts.push(`${spaces}y = ${n.y}f`);
            }
        }
        // Background color
        if ('fills' in node) {
            const fill = this.getFirstSolidFill(node.fills);
            if (fill) {
                const hex = this.rgbaToHex(fill);
                parts.push(`${spaces}setBackgroundColor(Color.parseColor("#${hex}"))`);
            }
        }
        return parts.join('\n');
    }
    // =========================================================================
    // Java View Generation
    // =========================================================================
    generateJavaView(nodeId, packageName, prefix, includeComments) {
        const node = this.sceneGraph.getNode(nodeId);
        if (!node)
            return '';
        const className = `${prefix}${this.sanitizeName(node.name || node.type)}View`;
        const parts = [];
        parts.push(`package ${packageName};`);
        parts.push('');
        if (includeComments) {
            parts.push('// Generated by DesignLibre');
            parts.push('// Do not modify directly');
            parts.push('');
        }
        parts.push('import android.content.Context;');
        parts.push('import android.graphics.Color;');
        parts.push('import android.util.AttributeSet;');
        parts.push('import android.view.View;');
        parts.push('import android.widget.FrameLayout;');
        parts.push('import android.widget.LinearLayout;');
        parts.push('import android.widget.TextView;');
        parts.push('');
        parts.push(`public class ${className} extends FrameLayout {`);
        parts.push('');
        parts.push(`    public ${className}(Context context) {`);
        parts.push('        super(context);');
        parts.push('        init();');
        parts.push('    }');
        parts.push('');
        parts.push(`    public ${className}(Context context, AttributeSet attrs) {`);
        parts.push('        super(context, attrs);');
        parts.push('        init();');
        parts.push('    }');
        parts.push('');
        parts.push(`    public ${className}(Context context, AttributeSet attrs, int defStyleAttr) {`);
        parts.push('        super(context, attrs, defStyleAttr);');
        parts.push('        init();');
        parts.push('    }');
        parts.push('');
        parts.push('    private void init() {');
        parts.push(this.generateJavaViewSetup(nodeId, 8));
        parts.push('    }');
        parts.push('}');
        return parts.join('\n');
    }
    generateJavaViewSetup(nodeId, indent) {
        const node = this.sceneGraph.getNode(nodeId);
        if (!node)
            return '';
        const spaces = ' '.repeat(indent);
        const parts = [];
        // Background color
        if ('fills' in node) {
            const fill = this.getFirstSolidFill(node.fills);
            if (fill) {
                const hex = this.rgbaToHex(fill);
                parts.push(`${spaces}setBackgroundColor(Color.parseColor("#${hex}"));`);
            }
        }
        // Add children
        const childIds = this.sceneGraph.getChildIds(nodeId);
        for (let i = 0; i < childIds.length; i++) {
            const childId = childIds[i];
            const childNode = this.sceneGraph.getNode(childId);
            if (!childNode)
                continue;
            parts.push('');
            parts.push(`${spaces}// Child: ${childNode.name || childNode.type}`);
            parts.push(`${spaces}View child${i} = new View(getContext());`);
            parts.push(this.generateJavaChildSetup(childId, `child${i}`, indent));
            parts.push(`${spaces}addView(child${i});`);
        }
        return parts.join('\n');
    }
    generateJavaChildSetup(nodeId, varName, indent) {
        const node = this.sceneGraph.getNode(nodeId);
        if (!node)
            return '';
        const spaces = ' '.repeat(indent);
        const parts = [];
        // Layout params
        if ('width' in node && 'height' in node) {
            const n = node;
            const w = Math.round(n.width);
            const h = Math.round(n.height);
            parts.push(`${spaces}${varName}.setLayoutParams(new FrameLayout.LayoutParams(${w}, ${h}));`);
        }
        // Background color
        if ('fills' in node) {
            const fill = this.getFirstSolidFill(node.fills);
            if (fill) {
                const hex = this.rgbaToHex(fill);
                parts.push(`${spaces}${varName}.setBackgroundColor(Color.parseColor("#${hex}"));`);
            }
        }
        return parts.join('\n');
    }
    // =========================================================================
    // Resource XML Generation
    // =========================================================================
    generateColorsXml() {
        const parts = [];
        parts.push('<?xml version="1.0" encoding="utf-8"?>');
        parts.push('<resources>');
        for (const [_key, color] of this.extractedColors) {
            const hex = this.rgbaToHex(color.rgba);
            parts.push(`    <color name="${color.name}">#${hex}</color>`);
        }
        parts.push('</resources>');
        return parts.join('\n');
    }
    generateDimensXml() {
        const parts = [];
        parts.push('<?xml version="1.0" encoding="utf-8"?>');
        parts.push('<resources>');
        for (const [value, name] of this.extractedDimens) {
            parts.push(`    <dimen name="${name}">${value}dp</dimen>`);
        }
        parts.push('</resources>');
        return parts.join('\n');
    }
    // =========================================================================
    // Helper Methods
    // =========================================================================
    extractDesignTokens(nodeId) {
        const node = this.sceneGraph.getNode(nodeId);
        if (!node)
            return;
        // Extract colors
        if ('fills' in node) {
            const fills = node.fills ?? [];
            for (const fill of fills) {
                if (fill.type === 'SOLID' && fill.visible !== false && fill.color) {
                    this.registerColor(fill.color);
                }
            }
        }
        if ('strokes' in node) {
            const strokes = node.strokes ?? [];
            for (const stroke of strokes) {
                if (stroke.type === 'SOLID' && stroke.visible !== false && stroke.color) {
                    this.registerColor(stroke.color);
                }
            }
        }
        // Extract dimensions
        if ('width' in node) {
            this.registerDimen(node.width);
        }
        if ('height' in node) {
            this.registerDimen(node.height);
        }
        if ('cornerRadius' in node) {
            this.registerDimen(node.cornerRadius);
        }
        const childIds = this.sceneGraph.getChildIds(nodeId);
        for (const childId of childIds) {
            this.extractDesignTokens(childId);
        }
    }
    registerColor(color) {
        const key = this.colorToKey(color);
        if (!this.extractedColors.has(key)) {
            const name = `designlibre_color_${++this.colorIndex}`;
            this.extractedColors.set(key, { name, rgba: color });
        }
        return this.extractedColors.get(key).name;
    }
    registerDimen(value) {
        const rounded = Math.round(value);
        if (!this.extractedDimens.has(rounded)) {
            const name = `designlibre_dimen_${++this.dimenIndex}`;
            this.extractedDimens.set(rounded, name);
        }
        return this.extractedDimens.get(rounded);
    }
    getColorName(color) {
        const key = this.colorToKey(color);
        return this.extractedColors.get(key)?.name ?? 'Color.Black';
    }
    colorToKey(color) {
        return `${color.r.toFixed(3)}-${color.g.toFixed(3)}-${color.b.toFixed(3)}-${color.a.toFixed(3)}`;
    }
    rgbaToHex(color) {
        const r = Math.round(color.r * 255).toString(16).padStart(2, '0');
        const g = Math.round(color.g * 255).toString(16).padStart(2, '0');
        const b = Math.round(color.b * 255).toString(16).padStart(2, '0');
        const a = Math.round(color.a * 255).toString(16).padStart(2, '0');
        return `${a}${r}${g}${b}`.toUpperCase();
    }
    getFirstSolidFill(fills) {
        if (!fills)
            return null;
        const solid = fills.find(f => f.type === 'SOLID' && f.visible !== false);
        return solid?.color ?? null;
    }
    kotlinFontWeight(weight) {
        if (weight <= 100)
            return 'Thin';
        if (weight <= 200)
            return 'ExtraLight';
        if (weight <= 300)
            return 'Light';
        if (weight <= 400)
            return 'Normal';
        if (weight <= 500)
            return 'Medium';
        if (weight <= 600)
            return 'SemiBold';
        if (weight <= 700)
            return 'Bold';
        if (weight <= 800)
            return 'ExtraBold';
        return 'Black';
    }
    sanitizeName(name) {
        return name
            .replace(/[^a-zA-Z0-9]/g, '')
            .replace(/^(\d)/, '_$1');
    }
    escapeString(str) {
        return str
            .replace(/\\/g, '\\\\')
            .replace(/"/g, '\\"')
            .replace(/\n/g, '\\n');
    }
}
/**
 * Create an Android code generator.
 */
export function createAndroidCodeGenerator(sceneGraph) {
    return new AndroidCodeGenerator(sceneGraph);
}
//# sourceMappingURL=android-code-generator.js.map