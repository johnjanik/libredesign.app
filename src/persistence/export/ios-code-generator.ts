/**
 * iOS Code Generator
 *
 * Generate Swift and Objective-C code from scene graph nodes.
 */

import type { NodeId } from '@core/types/common';
import type { RGBA } from '@core/types/color';
import type { VectorPath } from '@core/types/geometry';
import type { SceneGraph } from '@scene/graph/scene-graph';
import type { NodeData, FrameNodeData, VectorNodeData, TextNodeData } from '@scene/nodes/base-node';

/**
 * iOS code generation options
 */
export interface IOSCodeGeneratorOptions {
  /** Output language (default: 'swift') */
  language?: 'swift' | 'objc' | undefined;
  /** Use SwiftUI or UIKit (default: 'swiftui' for swift, 'uikit' for objc) */
  framework?: 'swiftui' | 'uikit' | undefined;
  /** Class/struct name prefix (default: '') */
  prefix?: string | undefined;
  /** Include preview provider (default: true, SwiftUI only) */
  includePreview?: boolean | undefined;
  /** Use extensions for colors (default: true) */
  useColorExtension?: boolean | undefined;
  /** Include comments (default: true) */
  includeComments?: boolean | undefined;
}

/**
 * iOS code generation result
 */
export interface IOSCodeGeneratorResult {
  /** Generated code */
  readonly code: string;
  /** Color extension code */
  readonly colorExtension: string;
  /** File extension */
  readonly extension: string;
  /** Blob for download */
  readonly blob: Blob;
  /** Download URL */
  readonly url: string;
}

/**
 * iOS Code Generator
 */
export class IOSCodeGenerator {
  private sceneGraph: SceneGraph;
  private colorIndex = 0;
  private extractedColors: Map<string, { name: string; rgba: RGBA }> = new Map();

  constructor(sceneGraph: SceneGraph) {
    this.sceneGraph = sceneGraph;
  }

  /**
   * Generate iOS code for a node.
   */
  generate(nodeId: NodeId, options: IOSCodeGeneratorOptions = {}): IOSCodeGeneratorResult {
    const language = options.language ?? 'swift';
    const framework = options.framework ?? (language === 'swift' ? 'swiftui' : 'uikit');
    const prefix = options.prefix ?? '';
    const includePreview = options.includePreview ?? true;
    const useColorExtension = options.useColorExtension ?? true;
    const includeComments = options.includeComments ?? true;

    // Reset extraction state
    this.colorIndex = 0;
    this.extractedColors.clear();

    // Extract colors first
    this.extractColors(nodeId);

    const node = this.sceneGraph.getNode(nodeId);
    if (!node) {
      throw new Error(`Node not found: ${nodeId}`);
    }

    let code: string;
    let colorExtension: string;

    if (language === 'swift') {
      if (framework === 'swiftui') {
        code = this.generateSwiftUI(nodeId, prefix, includePreview, includeComments);
        colorExtension = useColorExtension ? this.generateSwiftColorExtension() : '';
      } else {
        code = this.generateUIKit(nodeId, prefix, includeComments);
        colorExtension = useColorExtension ? this.generateUIKitColorExtension() : '';
      }
    } else {
      code = this.generateObjC(nodeId, prefix, includeComments);
      colorExtension = useColorExtension ? this.generateObjCColorExtension() : '';
    }

    const ext = language === 'swift' ? 'swift' : 'm';
    const blob = new Blob([code], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);

    return {
      code,
      colorExtension,
      extension: ext,
      blob,
      url,
    };
  }

  /**
   * Download the generated code.
   */
  download(
    nodeId: NodeId,
    filename?: string,
    options: IOSCodeGeneratorOptions = {}
  ): void {
    const result = this.generate(nodeId, options);
    const ext = result.extension;
    const finalFilename = filename ?? `DesignLibreView.${ext}`;

    const link = document.createElement('a');
    link.href = result.url;
    link.download = finalFilename;
    link.click();

    URL.revokeObjectURL(result.url);
  }

  // =========================================================================
  // Swift/SwiftUI Generation
  // =========================================================================

  private generateSwiftUI(
    nodeId: NodeId,
    prefix: string,
    includePreview: boolean,
    includeComments: boolean
  ): string {
    const node = this.sceneGraph.getNode(nodeId);
    if (!node) return '';

    const structName = `${prefix}${this.sanitizeName(node.name || node.type)}View`;

    const parts: string[] = [];

    // Header comment
    if (includeComments) {
      parts.push('// Generated by DesignLibre');
      parts.push('// Do not modify directly');
      parts.push('');
    }

    parts.push('import SwiftUI');
    parts.push('');

    // Main struct
    parts.push(`struct ${structName}: View {`);
    parts.push('    var body: some View {');
    parts.push(this.generateSwiftUIBody(nodeId, 8));
    parts.push('    }');
    parts.push('}');

    // Preview provider
    if (includePreview) {
      parts.push('');
      parts.push(`#Preview {`);
      parts.push(`    ${structName}()`);
      parts.push('}');
    }

    return parts.join('\n');
  }

  private generateSwiftUIBody(nodeId: NodeId, indent: number): string {
    const node = this.sceneGraph.getNode(nodeId);
    if (!node) return '';

    const spaces = ' '.repeat(indent);
    const parts: string[] = [];

    switch (node.type) {
      case 'FRAME':
        parts.push(this.generateSwiftUIFrame(node as FrameNodeData, nodeId, indent));
        break;
      case 'VECTOR':
        parts.push(this.generateSwiftUIVector(node as VectorNodeData, indent));
        break;
      case 'TEXT':
        parts.push(this.generateSwiftUIText(node as TextNodeData, indent));
        break;
      case 'GROUP':
        parts.push(this.generateSwiftUIGroup(nodeId, indent));
        break;
      default:
        // Generic container
        parts.push(`${spaces}EmptyView()`);
    }

    return parts.join('\n');
  }

  private generateSwiftUIFrame(
    node: FrameNodeData,
    nodeId: NodeId,
    indent: number
  ): string {
    const spaces = ' '.repeat(indent);
    const parts: string[] = [];

    const childIds = this.sceneGraph.getChildIds(nodeId);
    const hasChildren = childIds.length > 0;

    // Determine layout
    const isHorizontal = node.autoLayout?.mode === 'HORIZONTAL';
    const isVertical = node.autoLayout?.mode === 'VERTICAL';

    if (hasChildren) {
      if (isHorizontal) {
        parts.push(`${spaces}HStack(spacing: ${node.autoLayout?.itemSpacing ?? 0}) {`);
      } else if (isVertical) {
        parts.push(`${spaces}VStack(spacing: ${node.autoLayout?.itemSpacing ?? 0}) {`);
      } else {
        parts.push(`${spaces}ZStack {`);
      }

      for (const childId of childIds) {
        parts.push(this.generateSwiftUIBody(childId, indent + 4));
      }

      parts.push(`${spaces}}`);
    } else {
      parts.push(`${spaces}Rectangle()`);
    }

    // Apply modifiers
    const modifiers = this.generateSwiftUIModifiers(node, indent);
    if (modifiers) {
      parts.push(modifiers);
    }

    return parts.join('\n');
  }

  private generateSwiftUIVector(node: VectorNodeData, indent: number): string {
    const spaces = ' '.repeat(indent);
    const parts: string[] = [];

    const path = node.vectorPaths?.[0];
    if (path) {
      parts.push(`${spaces}Path { path in`);
      parts.push(this.generateSwiftUIPathCommands(path, indent + 4));
      parts.push(`${spaces}}`);

      // Apply fill
      const fill = this.getFirstSolidFill(node.fills);
      if (fill) {
        const colorName = this.getColorName(fill);
        parts.push(`${spaces}.fill(Color.${colorName})`);
      }

      // Apply stroke
      const stroke = this.getFirstSolidStroke(node.strokes);
      if (stroke) {
        const colorName = this.getColorName(stroke);
        parts.push(`${spaces}.stroke(Color.${colorName}, lineWidth: ${node.strokeWeight ?? 1})`);
      }
    }

    return parts.join('\n');
  }

  private generateSwiftUIPathCommands(path: VectorPath, indent: number): string {
    const spaces = ' '.repeat(indent);
    const parts: string[] = [];

    for (const cmd of path.commands) {
      switch (cmd.type) {
        case 'M':
          parts.push(`${spaces}path.move(to: CGPoint(x: ${cmd.x}, y: ${cmd.y}))`);
          break;
        case 'L':
          parts.push(`${spaces}path.addLine(to: CGPoint(x: ${cmd.x}, y: ${cmd.y}))`);
          break;
        case 'C':
          parts.push(`${spaces}path.addCurve(`);
          parts.push(`${spaces}    to: CGPoint(x: ${cmd.x}, y: ${cmd.y}),`);
          parts.push(`${spaces}    control1: CGPoint(x: ${cmd.x1}, y: ${cmd.y1}),`);
          parts.push(`${spaces}    control2: CGPoint(x: ${cmd.x2}, y: ${cmd.y2})`);
          parts.push(`${spaces})`);
          break;
        case 'Z':
          parts.push(`${spaces}path.closeSubpath()`);
          break;
      }
    }

    return parts.join('\n');
  }

  private generateSwiftUIText(node: TextNodeData, indent: number): string {
    const spaces = ' '.repeat(indent);
    const parts: string[] = [];

    const firstStyle = node.textStyles[0];
    const fontSize = firstStyle?.fontSize ?? 16;
    const fontWeight = this.swiftFontWeight(firstStyle?.fontWeight ?? 400);

    parts.push(`${spaces}Text("${this.escapeString(node.characters)}")`);
    parts.push(`${spaces}    .font(.system(size: ${fontSize}, weight: .${fontWeight}))`);

    // Text color
    const fill = this.getFirstSolidFill(node.fills);
    if (fill) {
      const colorName = this.getColorName(fill);
      parts.push(`${spaces}    .foregroundColor(Color.${colorName})`);
    }

    return parts.join('\n');
  }

  private generateSwiftUIGroup(nodeId: NodeId, indent: number): string {
    const spaces = ' '.repeat(indent);
    const parts: string[] = [];
    const childIds = this.sceneGraph.getChildIds(nodeId);

    parts.push(`${spaces}Group {`);
    for (const childId of childIds) {
      parts.push(this.generateSwiftUIBody(childId, indent + 4));
    }
    parts.push(`${spaces}}`);

    return parts.join('\n');
  }

  private generateSwiftUIModifiers(node: NodeData, indent: number): string {
    const spaces = ' '.repeat(indent);
    const parts: string[] = [];

    // Frame size
    if ('width' in node && 'height' in node) {
      const n = node as { width: number; height: number };
      parts.push(`${spaces}.frame(width: ${n.width}, height: ${n.height})`);
    }

    // Background
    if ('fills' in node) {
      const fill = this.getFirstSolidFill((node as FrameNodeData).fills);
      if (fill) {
        const colorName = this.getColorName(fill);
        parts.push(`${spaces}.background(Color.${colorName})`);
      }
    }

    // Corner radius
    if ('cornerRadius' in node) {
      const radius = (node as { cornerRadius: number }).cornerRadius;
      if (radius > 0) {
        parts.push(`${spaces}.cornerRadius(${radius})`);
      }
    }

    // Opacity
    if ('opacity' in node) {
      const opacity = (node as { opacity: number }).opacity;
      if (opacity !== 1) {
        parts.push(`${spaces}.opacity(${opacity})`);
      }
    }

    // Rotation
    if ('rotation' in node) {
      const rotation = (node as { rotation: number }).rotation;
      if (rotation && rotation !== 0) {
        parts.push(`${spaces}.rotationEffect(.degrees(${rotation}))`);
      }
    }

    // Shadow effects
    if ('effects' in node) {
      const effects = (node as { effects: readonly unknown[] }).effects ?? [];
      for (const effect of effects) {
        const e = effect as { type: string; visible?: boolean; color?: RGBA; offset?: { x: number; y: number }; radius?: number };
        if (e.type === 'DROP_SHADOW' && e.visible !== false && e.color) {
          const colorName = this.getColorName(e.color);
          parts.push(`${spaces}.shadow(color: Color.${colorName}, radius: ${e.radius ?? 0}, x: ${e.offset?.x ?? 0}, y: ${e.offset?.y ?? 0})`);
        }
      }
    }

    return parts.join('\n');
  }

  // =========================================================================
  // UIKit Generation
  // =========================================================================

  private generateUIKit(
    nodeId: NodeId,
    prefix: string,
    includeComments: boolean
  ): string {
    const node = this.sceneGraph.getNode(nodeId);
    if (!node) return '';

    const className = `${prefix}${this.sanitizeName(node.name || node.type)}View`;

    const parts: string[] = [];

    if (includeComments) {
      parts.push('// Generated by DesignLibre');
      parts.push('// Do not modify directly');
      parts.push('');
    }

    parts.push('import UIKit');
    parts.push('');

    parts.push(`class ${className}: UIView {`);
    parts.push('');
    parts.push('    override init(frame: CGRect) {');
    parts.push('        super.init(frame: frame)');
    parts.push('        setupView()');
    parts.push('    }');
    parts.push('');
    parts.push('    required init?(coder: NSCoder) {');
    parts.push('        super.init(coder: coder)');
    parts.push('        setupView()');
    parts.push('    }');
    parts.push('');
    parts.push('    private func setupView() {');
    parts.push(this.generateUIKitSetup(nodeId, 8));
    parts.push('    }');
    parts.push('}');

    return parts.join('\n');
  }

  private generateUIKitSetup(nodeId: NodeId, indent: number): string {
    const node = this.sceneGraph.getNode(nodeId);
    if (!node) return '';

    const spaces = ' '.repeat(indent);
    const parts: string[] = [];

    // Background color
    if ('fills' in node) {
      const fill = this.getFirstSolidFill((node as FrameNodeData).fills);
      if (fill) {
        const colorName = this.getColorName(fill);
        parts.push(`${spaces}backgroundColor = UIColor.${colorName}`);
      }
    }

    // Corner radius
    if ('cornerRadius' in node) {
      const radius = (node as { cornerRadius: number }).cornerRadius;
      if (radius > 0) {
        parts.push(`${spaces}layer.cornerRadius = ${radius}`);
        parts.push(`${spaces}clipsToBounds = true`);
      }
    }

    // Opacity
    if ('opacity' in node) {
      const opacity = (node as { opacity: number }).opacity;
      if (opacity !== 1) {
        parts.push(`${spaces}alpha = ${opacity}`);
      }
    }

    // Shadow
    if ('effects' in node) {
      const effects = (node as { effects: readonly unknown[] }).effects ?? [];
      for (const effect of effects) {
        const e = effect as { type: string; visible?: boolean; color?: RGBA; offset?: { x: number; y: number }; radius?: number };
        if (e.type === 'DROP_SHADOW' && e.visible !== false && e.color) {
          const colorName = this.getColorName(e.color);
          parts.push(`${spaces}layer.shadowColor = UIColor.${colorName}.cgColor`);
          parts.push(`${spaces}layer.shadowOffset = CGSize(width: ${e.offset?.x ?? 0}, height: ${e.offset?.y ?? 0})`);
          parts.push(`${spaces}layer.shadowRadius = ${e.radius ?? 0}`);
          parts.push(`${spaces}layer.shadowOpacity = 1.0`);
        }
      }
    }

    // Add child views
    const childIds = this.sceneGraph.getChildIds(nodeId);
    for (let i = 0; i < childIds.length; i++) {
      const childId = childIds[i]!;
      const childNode = this.sceneGraph.getNode(childId);
      if (!childNode) continue;

      parts.push('');
      parts.push(`${spaces}// Child: ${childNode.name || childNode.type}`);
      parts.push(`${spaces}let child${i} = UIView()`);
      parts.push(this.generateUIKitChildSetup(childId, `child${i}`, indent));
      parts.push(`${spaces}addSubview(child${i})`);
    }

    return parts.join('\n');
  }

  private generateUIKitChildSetup(nodeId: NodeId, varName: string, indent: number): string {
    const node = this.sceneGraph.getNode(nodeId);
    if (!node) return '';

    const spaces = ' '.repeat(indent);
    const parts: string[] = [];

    // Position and size
    if ('x' in node && 'y' in node && 'width' in node && 'height' in node) {
      const n = node as { x: number; y: number; width: number; height: number };
      parts.push(`${spaces}${varName}.frame = CGRect(x: ${n.x}, y: ${n.y}, width: ${n.width}, height: ${n.height})`);
    }

    // Background color
    if ('fills' in node) {
      const fill = this.getFirstSolidFill((node as FrameNodeData).fills);
      if (fill) {
        const colorName = this.getColorName(fill);
        parts.push(`${spaces}${varName}.backgroundColor = UIColor.${colorName}`);
      }
    }

    // Corner radius
    if ('cornerRadius' in node) {
      const radius = (node as { cornerRadius: number }).cornerRadius;
      if (radius > 0) {
        parts.push(`${spaces}${varName}.layer.cornerRadius = ${radius}`);
      }
    }

    return parts.join('\n');
  }

  // =========================================================================
  // Objective-C Generation
  // =========================================================================

  private generateObjC(
    nodeId: NodeId,
    prefix: string,
    includeComments: boolean
  ): string {
    const node = this.sceneGraph.getNode(nodeId);
    if (!node) return '';

    const className = `${prefix}${this.sanitizeName(node.name || node.type)}View`;

    const parts: string[] = [];

    if (includeComments) {
      parts.push('// Generated by DesignLibre');
      parts.push('// Do not modify directly');
      parts.push('');
    }

    // Header
    parts.push('#import <UIKit/UIKit.h>');
    parts.push('');
    parts.push(`@interface ${className} : UIView`);
    parts.push('@end');
    parts.push('');

    // Implementation
    parts.push(`@implementation ${className}`);
    parts.push('');
    parts.push('- (instancetype)initWithFrame:(CGRect)frame {');
    parts.push('    self = [super initWithFrame:frame];');
    parts.push('    if (self) {');
    parts.push('        [self setupView];');
    parts.push('    }');
    parts.push('    return self;');
    parts.push('}');
    parts.push('');
    parts.push('- (instancetype)initWithCoder:(NSCoder *)coder {');
    parts.push('    self = [super initWithCoder:coder];');
    parts.push('    if (self) {');
    parts.push('        [self setupView];');
    parts.push('    }');
    parts.push('    return self;');
    parts.push('}');
    parts.push('');
    parts.push('- (void)setupView {');
    parts.push(this.generateObjCSetup(nodeId, 4));
    parts.push('}');
    parts.push('');
    parts.push('@end');

    return parts.join('\n');
  }

  private generateObjCSetup(nodeId: NodeId, indent: number): string {
    const node = this.sceneGraph.getNode(nodeId);
    if (!node) return '';

    const spaces = ' '.repeat(indent);
    const parts: string[] = [];

    // Background color
    if ('fills' in node) {
      const fill = this.getFirstSolidFill((node as FrameNodeData).fills);
      if (fill) {
        parts.push(`${spaces}self.backgroundColor = [UIColor colorWithRed:${fill.r.toFixed(3)} green:${fill.g.toFixed(3)} blue:${fill.b.toFixed(3)} alpha:${fill.a.toFixed(3)}];`);
      }
    }

    // Corner radius
    if ('cornerRadius' in node) {
      const radius = (node as { cornerRadius: number }).cornerRadius;
      if (radius > 0) {
        parts.push(`${spaces}self.layer.cornerRadius = ${radius};`);
        parts.push(`${spaces}self.clipsToBounds = YES;`);
      }
    }

    // Opacity
    if ('opacity' in node) {
      const opacity = (node as { opacity: number }).opacity;
      if (opacity !== 1) {
        parts.push(`${spaces}self.alpha = ${opacity};`);
      }
    }

    return parts.join('\n');
  }

  // =========================================================================
  // Color Extension Generation
  // =========================================================================

  private generateSwiftColorExtension(): string {
    const parts: string[] = [];
    parts.push('import SwiftUI');
    parts.push('');
    parts.push('extension Color {');

    for (const [_key, color] of this.extractedColors) {
      const { r, g, b, a } = color.rgba;
      parts.push(`    static let ${color.name} = Color(red: ${r.toFixed(3)}, green: ${g.toFixed(3)}, blue: ${b.toFixed(3)}, opacity: ${a.toFixed(3)})`);
    }

    parts.push('}');
    return parts.join('\n');
  }

  private generateUIKitColorExtension(): string {
    const parts: string[] = [];
    parts.push('import UIKit');
    parts.push('');
    parts.push('extension UIColor {');

    for (const [_key, color] of this.extractedColors) {
      const { r, g, b, a } = color.rgba;
      parts.push(`    static let ${color.name} = UIColor(red: ${r.toFixed(3)}, green: ${g.toFixed(3)}, blue: ${b.toFixed(3)}, alpha: ${a.toFixed(3)})`);
    }

    parts.push('}');
    return parts.join('\n');
  }

  private generateObjCColorExtension(): string {
    const parts: string[] = [];
    parts.push('#import <UIKit/UIKit.h>');
    parts.push('');
    parts.push('@interface UIColor (DesignLibreColors)');

    for (const [_key, color] of this.extractedColors) {
      parts.push(`+ (UIColor *)${color.name};`);
    }

    parts.push('@end');
    parts.push('');
    parts.push('@implementation UIColor (DesignLibreColors)');

    for (const [_key, color] of this.extractedColors) {
      const { r, g, b, a } = color.rgba;
      parts.push(`+ (UIColor *)${color.name} {`);
      parts.push(`    return [UIColor colorWithRed:${r.toFixed(3)} green:${g.toFixed(3)} blue:${b.toFixed(3)} alpha:${a.toFixed(3)}];`);
      parts.push('}');
    }

    parts.push('@end');
    return parts.join('\n');
  }

  // =========================================================================
  // Helper Methods
  // =========================================================================

  private extractColors(nodeId: NodeId): void {
    const node = this.sceneGraph.getNode(nodeId);
    if (!node) return;

    if ('fills' in node) {
      const fills = (node as FrameNodeData).fills ?? [];
      for (const fill of fills) {
        if (fill.type === 'SOLID' && fill.visible !== false && fill.color) {
          this.registerColor(fill.color);
        }
      }
    }

    if ('strokes' in node) {
      const strokes = (node as VectorNodeData).strokes ?? [];
      for (const stroke of strokes) {
        if (stroke.type === 'SOLID' && stroke.visible !== false && stroke.color) {
          this.registerColor(stroke.color);
        }
      }
    }

    if ('effects' in node) {
      const effects = (node as { effects: readonly unknown[] }).effects ?? [];
      for (const effect of effects) {
        const e = effect as { color?: RGBA };
        if (e.color) {
          this.registerColor(e.color);
        }
      }
    }

    const childIds = this.sceneGraph.getChildIds(nodeId);
    for (const childId of childIds) {
      this.extractColors(childId);
    }
  }

  private registerColor(color: RGBA): string {
    const key = this.colorToKey(color);
    if (!this.extractedColors.has(key)) {
      const name = `designLibreColor${++this.colorIndex}`;
      this.extractedColors.set(key, { name, rgba: color });
    }
    return this.extractedColors.get(key)!.name;
  }

  private getColorName(color: RGBA): string {
    const key = this.colorToKey(color);
    return this.extractedColors.get(key)?.name ?? 'clear';
  }

  private colorToKey(color: RGBA): string {
    return `${color.r.toFixed(3)}-${color.g.toFixed(3)}-${color.b.toFixed(3)}-${color.a.toFixed(3)}`;
  }

  private getFirstSolidFill(fills: readonly { type: string; visible?: boolean; color?: RGBA }[] | undefined): RGBA | null {
    if (!fills) return null;
    const solid = fills.find(f => f.type === 'SOLID' && f.visible !== false);
    return solid?.color ?? null;
  }

  private getFirstSolidStroke(strokes: readonly { type: string; visible?: boolean; color?: RGBA }[] | undefined): RGBA | null {
    if (!strokes) return null;
    const solid = strokes.find(s => s.type === 'SOLID' && s.visible !== false);
    return solid?.color ?? null;
  }

  private swiftFontWeight(weight: number): string {
    if (weight <= 100) return 'ultraLight';
    if (weight <= 200) return 'thin';
    if (weight <= 300) return 'light';
    if (weight <= 400) return 'regular';
    if (weight <= 500) return 'medium';
    if (weight <= 600) return 'semibold';
    if (weight <= 700) return 'bold';
    if (weight <= 800) return 'heavy';
    return 'black';
  }

  private sanitizeName(name: string): string {
    return name
      .replace(/[^a-zA-Z0-9]/g, '')
      .replace(/^(\d)/, '_$1');
  }

  private escapeString(str: string): string {
    return str
      .replace(/\\/g, '\\\\')
      .replace(/"/g, '\\"')
      .replace(/\n/g, '\\n');
  }
}

/**
 * Create an iOS code generator.
 */
export function createIOSCodeGenerator(sceneGraph: SceneGraph): IOSCodeGenerator {
  return new IOSCodeGenerator(sceneGraph);
}
